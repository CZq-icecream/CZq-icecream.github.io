<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[对角线遍历]]></title>
    <url>%2F2019%2F06%2F06%2F%E7%BB%83%E4%B8%80%E7%BB%83%EF%BC%9F%2F%E5%AF%B9%E8%A7%92%E7%BA%BF%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[对角线遍历 给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。 示例： 输入: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] 输出: [1,2,4,7,5,3,6,8,9] 思路：分两种情况讨论，一种是向上走，一种是向下走。 如何区分当前属于向上或者向右呢？注意到斜着移动时不改变奇偶性（因为指向行和指向列的指针一加一减）。具体来说：就是两个下标相加为偶数时正在右上方移动，两个下标相加为奇数时正在往左下方移动。 向上走走到不能再走又分为两种情况，一种是可以向右走（例如M&gt;=N的矩形）；一种是向下走（M&lt;=N的矩形） 向下走与向上走同理，走到尽头也可以分为两种情况，一种是向下走（例如M&gt;=N的情况）；另一种是向右走（例如M&lt;=N的情况） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123; public int[] findDiagonalOrder(int[][] matrix) &#123; if(matrix == null || matrix.length == 0)&#123; return new int[0]; &#125; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); int row = matrix.length, col = matrix[0].length; int i = 0, j = 0; while (i &lt; row &amp;&amp; j &lt; col)&#123; list.add(matrix[i][j]); if ((i+j)%2==0)&#123; //向上走 if (i == 0)&#123; if (j == col -1)&#123; i += 1; &#125;else&#123; j += 1; &#125; &#125;else if (j == col - 1)&#123; i += 1; &#125;else&#123; i -= 1; j += 1; &#125; &#125;else&#123; //向下走 if (j == 0)&#123; if (i == row - 1)&#123; j += 1; &#125;else&#123; i += 1; &#125; &#125;else if (i == row - 1)&#123; j += 1; &#125;else&#123; i += 1; j -= 1; &#125; &#125; &#125; int[] res = new int[list.size()]; for (i = 0; i &lt; list.size(); i++)&#123; res[i] = list.get(i); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>练一练？</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Partition Labels]]></title>
    <url>%2F2019%2F06%2F02%2F%E7%BB%83%E4%B8%80%E7%BB%83%EF%BC%9F%2FPartition-Labels%2F</url>
    <content type="text"><![CDATA[题目 思路： 找出每个字符第一次出现和最后一次出现的位置，这样就可以看成是一个又一个的区间，抽象出来就是合并区间的操作。（题目也可以改成给定一些区间，将overlap的地方合并之后还有几个区间） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import java.util.ArrayList;import java.util.Arrays;import java.util.Scanner;public class OneTwo&#123; public static void main(String[] args) &#123; System.out.println(partitionLabels(&quot;helloworld&quot;)); System.out.println(partitionLabels(&quot;ababfeefhijkh&quot;)); &#125; public static int partitionLabels(String s)&#123; if (s == null || s.length() == 0)&#123; return 0; &#125; Interval[] intervals = new Interval[26]; for (int i = 0; i &lt; intervals.length; i++)&#123; intervals[i] = new Interval(); intervals[i].left = 0; intervals[i].right = 0; &#125; for (int i = 0; i &lt; s.length(); i++)&#123; char ch = s.charAt(i); intervals[ch-&apos;a&apos;].left = intervals[ch-&apos;a&apos;].left == 0 ? i+1 : Math.min(intervals[ch-&apos;a&apos;].left, i+1); intervals[ch-&apos;a&apos;].right = intervals[ch-&apos;a&apos;].right == 0 ? i+1 : Math.max(intervals[ch-&apos;a&apos;].right, i+1); &#125; Arrays.sort(intervals); int sum = 0; int left = 1; int right = 1; for (int i = 1; i &lt; intervals.length; i++)&#123; if (intervals[i].left &gt; right)&#123; sum++; left = intervals[i].left; right = intervals[i].right; &#125;else&#123; right = Math.max(right, intervals[i].right); &#125; if (i == intervals.length - 1)&#123; sum++; &#125; &#125; return sum; &#125;&#125;class Interval implements Comparable&lt;Interval&gt;&#123; int left = 0; int right = 0; Interval()&#123;&#125; @Override public int compareTo(Interval to)&#123; if (left != to.left)&#123; return left - to.left; &#125;else&#123; return right - to.right; &#125; &#125;&#125;]]></content>
      <categories>
        <category>练一练？</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《巨人的陨落》随笔？]]></title>
    <url>%2F2019%2F06%2F02%2F%E5%B7%A8%E4%BA%BA%E7%9A%84%E9%99%A8%E8%90%BD%2F</url>
    <content type="text"><![CDATA[README感谢学校图书馆和QQ的合作，为我们提供了免费的正版电子书（希望在关闭前能把扫到的几本书看完…更正，毕业前） 。这篇文章既不是读后感也不是赏析，只是个人的肤浅见解和茶余饭后的瞎BB。 2019-06-02书刚看过半，终于明白了：这是一部以历史为原型的小说。以一战前后为背景，讲述了渺小的个人在战争中的故事，从这几个人的身上可以窥见社会的缩影。贵族也好，工人也罢，所有人的命运都因为战争而改变。作者为我们开启了上帝视角，带我(们，需要加们吗)走进一个波澜壮阔的时代，也带我(们)了解了一个从未感受过的一战，那就是在历史书上最容易被忽视的——生命，和我们一样有情感、有思想、有梦想的生命，正是这些与我们并无差异的生命共同构成了这段历史。 Three years I’ve though of nothing except Titanic. But I never got it. I never let it in.——Titanic 作者采用分镜头的写法，主要介绍了五个国家的几个家庭（不容易计算就没数了），这几个家庭的命运看似独立，实则相互联系，纵横交织。作者以宏大的历史为背景，为我们讲述了一个精彩的故事，在这里，巨人陨落，英雄崛起。 2019-06-03 - 2019-06-04吃饱了再写一点 五个国家的大致概况。 英国 罢工频繁，社会主义思想盛行； 爱尔兰争取独立（？不太记得）； 自由党和保守党之争，首相软弱无力，面对战争摇摆不定，最终将英国推向一战； 议会分为上议院和下议院，上议院由贵族组成，下议院由人民选举； 应该处于慢慢没落的时期（从菲茨认为英国应该领导世界的想法看出来，不少国家已经开始挑战英国的霸主地位）； 普法做得很到位，或者说民主精神深入人心（但是上议院的席位由出身决定，看起来也不民主）。比利小学没念完就成了矿工，这应该是工人阶级的普遍情况，但是英国人知道通过立法、通过投票的手段争取和维护自己的权益。 俄国 腐败至极：德国的百姓可以低价买到俄国生产的鞋子，俄国士兵却要赤脚作战；牧师猥亵儿童；内部的政府官员自愿出卖国家；俄国警察可以随便殴打，逮捕群众；特权阶级可以随意处死百姓。 沙皇的权威在一二十年内不断下降。格雷戈里小时候被父母带着在路边跪拜沙皇（沙皇是爸爸）—&gt; 母亲带着格雷戈里两兄弟跪下求见沙皇（沙皇出于某些理由让百姓受苦）—&gt; 格雷戈里兵变（去你妈的沙皇）。愚蠢的皇室广播仇恨的种子，亲手培养自己的掘墓人。 德国 欧洲崛起的强国。普鲁士崛起，文治武功，在普法战争中打败法国，逼迫法国割让阿尔萨斯和洛林，最终统一了整个德意志，成为欧洲的强国。 谋求新的殖民地，以及有扩张的野心（从与墨西哥的py交易可以看出，与墨西哥做军火生意，同时希望与英国战争时墨西哥可以对英国实行石油禁运，这笔生意实际上同时惹到英国和美国） 皇帝和大臣过于傲慢，自认为什么都懂，低估了美国的力量。 奥地利 着墨较少，在谈到沃尔特的表弟时提及。萨拉热窝事件，斐迪南作为奥地利的继承人被塞尔维亚人强杀，至于是由塞尔维亚政府组织还是自发的，已经无所谓了。奥地利强迫塞尔维亚政府接受条约，大战一触即发。然而我搞不懂为什么沃尔特的表弟一再强调：奥地利必须进攻。因为尊严受到践踏？还是国家利益受到损害？还是奥地利发生了国内危机需要一场战争？ 美国 崛起的强国，并且国力持续强盛，工人的生活条件也最好。和其他国家一样，美国也有罢工，也有工会，美国梦并不像欧洲人宣传的那么好，不过是刚脱虎口，又入狼窝。 一战最大的赢家，大发战争财，出售军火和物资，同时贷款给协约国支持作战。然而威尔逊总统却又希望和平，建立国际秩序，真是讽刺（总统不过是资本选举出来的代言人）。 一战后期向德国宣战，这是显然的。威尔逊口口声声希望和平，却拉偏架：协约国和同盟国作战，美国为协约国提供物资和军火，同盟国对来往货轮进行无差别攻击我认为没什么不对的，这些货轮事实上也参与了战争，严格来说，是美国人把自己推向了战争，他们从一开始就参与了战争。 法国 革命不断，当然也不断地把国王推上断头台？在一战中依靠英国补给和俄国人在德国另一侧的牵制得以苟延残喘。看起来弱爆了？一战被吊打，二战直接亡国？实际上是对德作战主力军？ 2019-06-05写一写各个家庭的情况 英国比利家 比利 出生在英国的矿工家庭，父亲是工会的重要人物，虽然只念了小学，但从小接受父亲的熏陶，拥有演讲才能以及分辨政府消息真伪的能力。 善良：相信有上帝的存在，在矿井中被恶意捉弄时凭借对上帝的信仰挺过了没有光线的时间，从此人称“耶稣比利”（原来叫比利乘二）。 勇敢：发生矿难时挺身而出，救出了XXX(忘记名字了╮(￣▽￣)╭)，然而他已经被烧死了，所以冒死拖出来的是一具尸体；顶撞父亲(为姐姐辩护）；身先士卒，带领阿伯罗温的小队成功拿下敌人一个火力点；爱上了有两个孩子的单身母亲米尔德里德(强调单身母亲的原因是因为世俗对单身母亲带有敌意，过去如此，现在大概也是这样，然而单身母亲作为弱势群体不是应该受到更多的关怀吗)。 聪明：得益于其父亲，能够看穿政府的谎言和伎俩，以及可以从不同的角度看待事物；在战场上总能想到好办法度过难关，带领战友在战场上一同生存。 口无遮拦：想说的东西必须一吐为快，在作战中慢慢看清战争的真相，因此多次顶撞上级，引发上级不满。 艾瑟尔 比利的姐姐，善良聪明，曾经在伯爵的家中打工，爱上伯爵，后因怀孕而遭到驱逐，成为普通的女工。和比利一样受到父亲的很多影响。 之前对上层社会是抱有幻想的，我想可能是在伯爵的别墅待得太久了，又爱上了菲茨的缘故。在发生矿难时提出希望国王慰问的意见，提出发放食物给因发生矿难而罢工的矿工的孩子，提出这些建议的理由是她希望人和人可以互相理解，让上层阶级可以多关心下层人民。被赶出别墅之后，受到了许多不公正的对待(一是因为女性的身份，二是因为单身母亲)成为女权主义者，为女性权益奔走发声，在这一过程中，也慢慢地看清资本家的面目(从对菲茨的态度可以看出，爱情让人盲目，喜欢他的时候浑身发光，不喜欢的时候马上发现其冷酷、自私的本性╮(￣▽￣)╭)。 比利的父亲 工会的重要代表，冷静，用特有的方式关爱家人，对子女可能过于严厉。一直把比利当孩子看待，比利为其姐姐与父亲大吵一架之后父子之间几乎没有像样的交流了，直到比利参军时，才将他当成大人对待(父母的通病吗╮(￣▽￣)╭)。因艾维尔怀孕一度与她决裂。 比利的母亲 比利的外公 着墨不多，就和正常人的母亲和正常人的外公一样。母亲总能看穿比利的心思。 伯尼 艾薇尔的丈夫，工会成员，十分聪明，能够条理清晰地解释一件事。艾薇尔喜欢菲茨，最终发现伯尼才是自己的精神伴侣，遂接受伯尼的追求。 菲茨家 碧公主 俄国公主，对百姓没有同情心（怪不得你们家会被推翻），远嫁英国，但从未把英国当成家，小时候就跟着哥哥处死三个农民，因为它们的牛在自家土地上吃草。冷酷自私，追求享受，喜欢炫耀，虽然长得很漂亮，但是与性格形成了反差，让人觉得恶心。 菲茨 世袭伯爵，英国最富有的人之一。不过在我看来就是蠢猪一只，书中最讨厌的角色，没有之一。虚伪；冷酷；虚荣傲慢；不负责任；满脑子想着玩女人；虽然接受过贵族教育，但是其智力表现还不如只读完小学的工人阶级；完美地诠释什么叫“肉食者鄙”。如果非要说点好话，他的优点就是长得帅和有钱。 还是多写几句话骂他吧。 虚伪 为罢工工人的孩子提供食物 这是艾瑟尔出的主意，看起来菲茨似乎做了件好事。但实际上，菲茨是煤矿的真正主人（从法律上来说，当然马克思会反对的）。菲茨不直接经营煤矿，但是会按时收取租金和一定比例的利润，工人罢工是因为煤矿公司赶走了遇到矿难的矿工的妻子，菲茨拿着剥削矿工的钱招待矿工的孩子，还想博得慈善的称号。 资助或开办医院、收容所（？）等地方 这些实际上是茉黛在操作，只不过花的是伯爵的钱。他自己甚至不知道有这些事情，只是茉黛出于伯爵名声的考虑为菲茨操劳。 拄着拐杖，戴着眼罩参加追悼会 一场作秀而已，表明自己负伤也为国家作出了共享。然而并非如此。 首先，菲茨是支持这场战争的，没有战争就不会有牺牲。 其次，菲茨作为战斗的指挥官，这些士兵的牺牲与他的无能和不作为密切相关。 最后，尽管造成了这么多的牺牲，这么多的家破人亡，菲茨依旧呼吁继续战争。 菲茨不切腹谢罪也应感到惭愧和自责，但是却腆着B脸参加追悼会？毫无战绩，还在前线玩女人的军官也有资格和牺牲者相提并论？ 没有责任感 对于国家：支持英国参战；不懂指挥却越级上报 对于家庭：从书上来看，那个年代的英国应该是一夫一妻制，菲茨的枪却频频走火，这里放一枪，那里开一炮。在家里搞女管家，肚子弄大了之后希望用一年25镑打发走她；到法国巴黎作战，和酒吧女孩睡到一块（碧还在怀孕）；到俄国参加反布尔什维克战斗，和俄国女孩睡到一块。然后做完了之后感觉有轻微的愧疚感。 智力 这个没啥好说，精虫上脑的家伙能有什么智力。]]></content>
      <categories>
        <category>码畜的自我修养</category>
      </categories>
      <tags>
        <tag>瞎BB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java泛型(1)]]></title>
    <url>%2F2019%2F06%2F01%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%B3%9B%E5%9E%8B-1%2F</url>
    <content type="text"><![CDATA[泛型是什么泛型是程序设计语言的特性，类似于C++的模版类 为什么需要泛型因为懒 泛型的简单使用用菱形运算符括起来，放在正确的位置就行了。 泛型类12345678910111213141516171819202122232425262728public class GenericClassTest&#123; public static void main(String[] args)&#123; Pair&lt;Integer, String&gt; pair = new Pair&lt;&gt;(10, &quot;hello&quot;); System.out.println(pair.getKey()); System.out.println(pair.getValue()); &#125;&#125;//泛型类写法class Pair&lt;K, V&gt;&#123; K key; V value; public Pair(K key, V value)&#123; this.key = key; this.value = value; &#125; public Pair()&#123; &#125; public K getKey()&#123; return key; &#125; public V getValue()&#123; return value; &#125;&#125; 泛型方法12345678910111213141516171819202122232425262728293031323334353637383940public class GenericFunTest&#123; public static void main(String[] args)&#123; System.out.println(getString(&quot;hello&quot;)); System.out.println(getString(&quot;world&quot;, &quot;nothing&quot;)); System.out.println(getString(new String[]&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;)); String[] a = new String[]&#123;&quot;d&quot;, &quot;e&quot;, &quot;f&quot;&#125;; System.out.println(getString(a)); &#125; //泛型写在返回值之前 public static&lt;T&gt; String getString(T input)&#123; System.out.println(&quot;public static&lt;T&gt; String getString(T)&quot;); return input.toString(); &#125; public static&lt;T, V&gt; String getString(T input, V nouse)&#123; System.out.println(&quot;public static&lt;T,V&gt; String getString(T, V)&quot;); return input.toString(); &#125; //也可以传入多个泛型 public static&lt;T&gt; String getString(T...a)&#123; System.out.println(&quot;public static&lt;T&gt; String getString(T...a)&quot;); StringBuffer sb = new StringBuffer(); for (T temp:a)&#123; sb.append(temp.toString()); &#125; return sb.toString(); &#125; //这种方法和上面的定义等价 //写一个就好 public static&lt;T&gt; String getString(T[] a)&#123; System.out.println(&quot;public static&lt;T&gt; String getString(T[]a)&quot;); StringBuffer sb = new StringBuffer(); for (int i = 0; i &lt; a.length; i++)&#123; sb.append(a[i].toString()); &#125; return sb.toString(); &#125;&#125; 泛型的复杂使用以在集合中找到最小数为例，逐渐改进泛型的写法 类型限界（type bound）假如我们希望找出一个数组中的最小值，但又不愿为每个类型的数组都写基本相同的代码，这时候可以使用泛型。但不是所有的元素都是可以比较的，因此需要限定传入的数组参数，具体来说就是传入实现了Comparable接口的元素。 1234567891011121314151617181920212223242526272829303132333435public static&lt;T extends Comparable&gt; T min(T[] array)&#123; System.out.println(&quot;public static&lt;T extends Comparable&gt; T min(T[] array)&quot;); if (array == null || array.length == 0)&#123; return null; &#125; T res = array[0]; for (int i = 1; i &lt; array.length; i++)&#123; if (res.compareTo(array[i]) &gt; 0)&#123; res = array[i]; &#125; &#125; return res;&#125; //如果希望有多个限定呢？可以写成这样//这两个函数实际上重复了，下面这个包含了上面那个，写一个就好 public static&lt;T extends Comparable &amp; Serializable&gt; T min(T[] array)&#123; System.out.println(&quot;public static&lt;T extends Comparable &amp; Serializable&gt; T min(T[] array)&quot;); if (array == null || array.length == 0)&#123; return null; &#125; T res = array[0]; for (int i = 1; i &lt; array.length; i++)&#123; if (res.compareTo(array[i]) &gt; 0)&#123; res = array[i]; &#125; &#125; return res; &#125;public static void main(String[] args) &#123; Integer[] test = new Integer[]&#123;1,2,3,4,5&#125;; Integer res = min(test); System.out.println(res);&#125; 第一次修改以上代码有缺陷，在if条件内，编译之后有这样的提示：对作为原始类型Comparable的成员的compareTo(T)的调用未经过检查 Comparable本身就是泛型接口，所以进行第一次修改，改成这样：1public static&lt;T extends Comparable&lt;T&gt;&gt; min(T[] array) 改成这样好在哪里？编译时不会提示使用了未检查或不安全的操作。 不安全的操作是什么？我们只希望T和T进行比较，所以在Comparable后面又加上了限定类型T。 例如这样子（想了好久的例子，不知道恰不恰当） 123456789101112131415161718192021222324252627282930313233343536373839404142class A implements Comparable&lt;A&gt;&#123; int value; A(int value)&#123; this.value = value; &#125; A()&#123;&#125; @Override public int compareTo(A a)&#123; if (value &gt; a.value)&#123; return 1; &#125;else if (value &lt; a.value)&#123; return -1; &#125; return 0; &#125;&#125;class B implements Comparable&lt;B&gt;&#123; int value; B()&#123;&#125; B(int value)&#123; this.value = value; &#125; @Override public int compareTo(B b)&#123; if (value &gt; b.value)&#123; return 1; &#125;else if (value &lt; b.value)&#123; return -1; &#125; return 0; &#125;&#125;public static&lt;T extends Comparable&gt; int min(T a, T b)&#123; return a.compareTo(b);&#125;public static void main(String[] args) &#123; A a = new A(10); B b = new B(5); System.out.println(min(a, b));&#125; 上面这段代码可以通过编译，但是运行时出错： Exception in thread “main” java.lang.ClassCastException:B cannot be cast to A 但是利用第一次修改，在传参时就可以检查出错误了 协变 还不够完美，还可以再复杂一点。在这之前先介绍个名词，covariant（协变） 百度百科的解释： 协变是在计算机科学中，描述具有父/子型别关系的多个型别通过型别构造器、构造出的多个复杂型别之间是否有父/子型别关系的用语。 那么问题来了，什么是型别？ 停，这样下去是没有止境的，让这些定义吃屎去吧，写出来的词语连汉语词典都查不到。 直接看代码：有一个抽象父类Shape，两个子类Circle和Oval各自继承Shape 1234567891011121314151617181920212223abstract class Shape&#123; public abstract String getShape();&#125;class Circle extends Shape&#123; public String getShape()&#123; return &quot;circle&quot;; &#125;&#125;class Oval extends Shape&#123; public String getShape()&#123; return &quot;oval&quot;; &#125;&#125;public static void main(String[] args) &#123; Shape[] shapes = new Circle[3]; shapes[0] = new Oval(); //编译可以通过，但是运行时报错，会抛出ArrayStoreException //shapes数组实际上存的是Circle的引用，但是Oval不是Circle所以报错 //System.out.println(shapes[0].getShape()); //Shape[]可以放Circle也可以放Oval，这就是协变&#125; 可以看到数组是协变的，but集合不是协变的，也就是123//数组是协变的，但集合不是协变的，例如以下代码无法运行 List&lt;Circle&gt; list = new ArrayList&lt;Circle&gt;(); list.add(new Circle()); 不是协变的也就缺少了灵活性（也就是需要多写代码），所以这会限制集合的使用（因为不想多写代码），为了弥补这个不足，就有了通配符 最后一次修改1public static&lt;T extends Comparable&lt;? super T&gt;&gt; T min(T[] array) 为什么写成这样？因为假如有个类A实现了Comparable&lt;A&gt;的接口，类B继承了A，A is-a Comparable&lt;A&gt;，这个是显然的，而B is-a Comparable&lt;A&gt;，但是B is-not-a Comparable&lt;B&gt;。所以min()方法中不能传入数组B。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class A implements Comparable&lt;A&gt;&#123; int value; A()&#123;&#125; A(int value)&#123; this.value = value; &#125; @Override public int compareTo(A a)&#123; if (value &lt; a.value)&#123; return -1; &#125;else if (value &gt; a.value)&#123; return 1; &#125;else&#123; return 0; &#125; &#125;&#125;class B extends A&#123; int value; B()&#123;&#125; B(int value)&#123; this.value = value; &#125; @Override public int compareTo(B b)&#123; if (value &gt; b.value)&#123; return 1; &#125;else if (value &lt; b.value)&#123; return -1; &#125; return 0; &#125;&#125;public static&lt;T extends Comparable&lt;? super T&gt;&gt; T min(T[] array)&#123; System.out.println(&quot;public static&lt;T extends Comparable&gt; T min(T[] array)&quot;); if (array == null || array.length == 0)&#123; return null; &#125; T res = array[0]; for (int i = 1; i &lt; array.length; i++)&#123; if (res.compareTo(array[i]) &gt; 0)&#123; res = array[i]; &#125; &#125; return res;&#125;public static void main(String[] args) &#123; B[] bs = new B[2]; bs[0] = new B(1); bs[1] = new B(2); B res = min(bs); System.out.println(res.value);&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Minimum Size Subarray Sum]]></title>
    <url>%2F2019%2F05%2F30%2F%E7%BB%83%E4%B8%80%E7%BB%83%EF%BC%9F%2FMinimum-Size-Subarray-Sum%2F</url>
    <content type="text"><![CDATA[题目 思路：利用左右两个指针，分别指向Subarray的左边和右边。 如果Subarray的和大于s，更新最小的长度，减去左边的指针对应的值，将左边的指针向右移动； 如果Subarray的和小于s，将右边的指针向右移动，同时更新和 1234567891011121314151617181920212223242526272829303132public class Eight&#123; public static void main(String[] args)&#123; System.out.println(minSubArrayLen(7, new int[]&#123;2,3,1,2,4,3&#125;)); &#125; //s &gt; 0, and any element in nums are bigger than zero public static int minSubArrayLen(int s, int[] nums)&#123; if (nums == null || nums.length == 0)&#123; return 0; &#125; int length = 0; int sum = 0; int leftPos = 0; int rightPos = 0; while (rightPos &lt;= nums.length)&#123; if (sum &gt;= s)&#123; length = length == 0 ? rightPos - leftPos : Math.min(length, rightPos - leftPos); sum -= nums[leftPos++]; &#125;else&#123; if (rightPos == nums.length)&#123; break; &#125; sum += nums[rightPos++]; &#125; &#125; return length; &#125;&#125;]]></content>
      <categories>
        <category>练一练？</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Trapping Rain Water]]></title>
    <url>%2F2019%2F05%2F30%2F%E7%BB%83%E4%B8%80%E7%BB%83%EF%BC%9F%2FTrapping-Rain-Water%2F</url>
    <content type="text"><![CDATA[题目 思路： 拆开来看，判断每个位置还能装多少水，这样每个位置能装的水取决于该位置左右两边的最大值 从左到右扫一遍，得到数组在该位置的左边的最大值（包括这个数） 从右到左扫一遍，得到数组在该位置的右边的最大值（包括这个数） 重新扫一遍数组，判断这个数是否比左边的最大值和右边的最大值小(可以和第二步一起做，减少一次遍历的时间） 12345678910111213141516171819202122232425public static int trap(int[] height)&#123; if (height == null || height.length &lt;= 2)&#123; return 0; &#125; int[] head = new int[height.length]; int[] tail = new int[height.length]; head[0] = height[0]; for (int i = 1; i &lt; height.length; i++)&#123; head[i] = Math.max(head[i-1], height[i]); &#125; tail[height.length - 1] = height[height.length - 1]; for (int i = height.length - 2; i &gt;= 0; i--)&#123; tail[i] = Math.max(tail[i+1], height[i]); &#125; int sum = 0; for (int i = 1; i &lt; height.length - 1; i++)&#123; if (height[i] &lt; head[i] &amp;&amp; height[i] &lt; tail[i])&#123; sum += Math.min(head[i], tail[i]) - height[i]; &#125; &#125; return sum; &#125;]]></content>
      <categories>
        <category>练一练？</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UML类图]]></title>
    <url>%2F2019%2F05%2F27%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FUML%E7%B1%BB%E5%9B%BE%2FUML%E7%B1%BB%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[UML：Unified Modeling Language，统一建模语言。是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。 为了更好地读懂和理解设计模式需要学习UML（通过图形分析各个类之间的关系比通过代码更加直观易懂），既然学了UML类图，所以再顺便学了一下如何使用StarUML绘制来绘制UML类图。 绘图工具：开源的StarUML 参考资料：StarUML使用教程 类图主要包括这几个部分：类（Class）、接口（Interface）、双向关联（Association）、单向关联（DirectedAssociation）、聚合关系（Aggregation）、组合关系（Composition）、依赖关系（Dependency）、泛化关系（Generalization）、实现（Realization） StarUML中的类视图选项。先学上面列举的，暂时够用就行。 类视图类视图的表示方法 12345678910public class Person&#123; private int age; public String name; protected String race; public Person()&#123;&#125; public Person(int age, String name, String race)&#123;&#125; public int getAge()&#123; return age; &#125;&#125; 用UML类图表示的Person如下 上面是Attribute，也就是字段（属性），同一行分别表示：访问权限（可见性） 字段名 类型 “-“:private “+”:public “#”:protected “~”:package（默认访问权限） 下方是Operation（应该也可以叫Method），也就是方法。对应的是 访问权限 方法名 返回类型 接口123public interface IShape&#123; double getArea();&#125; 跟类的UML表示方法基本一样，只是上方多了&lt;&lt;&gt;&gt; 类与类的关系双向关联（Association）用不带箭头的实线表示。 老师给多个同学上课，同学有多个老师。 单向关联（DirectedAssociation）用带箭头的实现表示。 顾客的信息包括产品信息，产品信息不包括顾客 聚合关系（Aggregation）常见表示方法：一端带箭头，一端带空心菱形的实线 HAS-A。整体与部分的关系。一个对象作为另一个对象的成员存在，或者说一个对象是另一个对象的一部分。成员是整体对象的一部分，但是成员对象也可以脱离整体对象存在。 引擎是汽车的一部分，所以汽车和引擎是聚合关系。 表示方法似乎有两种，一种带箭头，一种不带箭头 带箭头的用得似乎更多一些？ 组合关系（Composition）常见表示方法：一端带箭头，一端带实心菱形的实线。 整体与部分的关系。但是整体对象可以控制成员对象的生命周期，成员对象与整体是同生共死的关系。 还是用汽车和引擎的例子。 同样是带箭头和不带箭头的画法。 泛化关系（Generalization）用一端带空心三角形的实线表示。 IS-A。直接理解为继承就行 依赖关系（Dependency）用带箭头的虚线表示。 USE-A的关系。一个对象需要使用另一个对象 #类与接口的关系 实现关系（Realization）用一端带空心三角形的虚线表示 实现接口。 扩展各种关系的强弱顺序 泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖 关系的强弱指什么？ 类与类之间的耦合度。可以理解为其中一个类发生变化时对另外一个类的影响程度。 为什么是上面那个顺序？ 这个问题慢慢想。 通过类图寻找关键的类 实体类：实体类对应系统需求中的每个实体，它们通常需要保存在永久存储体中，一般使用数据库表或文件来记录，实体类既包括存储和传递数据的类，还包括操作数据的类。实体类来源于需求说明中的名词，如学生、商品等。 控制类：控制类用于体现应用程序的执行逻辑，提供相应的业务操作，将控制类抽象出来可以降低界面和数据库之间的耦合度。控制类一般是由动宾结构的短语（动词+名词）转化来的名词，如增加商品对应有一个商品增加类，注册对应有一个用户注册类等 边界类：边界类用于对外部用户与系统之间的交互对象进行抽象，主要包括界面类，如对话框、窗口、菜单等。 这个在学习过程中慢慢体会。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式README]]></title>
    <url>%2F2019%2F05%2F26%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FREADME%2F</url>
    <content type="text"><![CDATA[说明用于学习设计模式 前置知识 UML类图 设计模式 Iterator(迭代器)模式 Adapter(适配器)模式 Template Method(模版)模式 Factory Method(工厂)模式 Singleton(单例)模式 Prototype(原型)模式 Builder(建造者)模式 Abstract Factory(抽象工厂)模式 Bridge(桥)模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迭代器模式]]></title>
    <url>%2F2019%2F05%2F25%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[hexo自动生成的文章]]></title>
    <url>%2F2019%2F05%2F16%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
