<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Minimum Size Subarray Sum]]></title>
    <url>%2F2019%2F05%2F30%2F%E7%AE%97%E6%B3%95%E9%A2%98%2FMinimum-Size-Subarray-Sum%2F</url>
    <content type="text"><![CDATA[题目 思路：利用左右两个指针，分别指向当前子数组的左边和右边。 如果子数组的和大于s，更新最小的长度，减去左边的指针对应的值，将左边的指针向右移动； 如果子数组的和小于s，将右边的指针向右移动，同时更新和 1234567891011121314151617181920212223242526272829303132public class Eight&#123; public static void main(String[] args)&#123; System.out.println(minSubArrayLen(7, new int[]&#123;2,3,1,2,4,3&#125;)); &#125; //s &gt; 0, and any element in nums are bigger than zero public static int minSubArrayLen(int s, int[] nums)&#123; if (nums == null || nums.length == 0)&#123; return 0; &#125; int length = 0; int sum = 0; int leftPos = 0; int rightPos = 0; while (rightPos &lt;= nums.length)&#123; if (sum &gt;= s)&#123; length = length == 0 ? rightPos - leftPos : Math.min(length, rightPos - leftPos); sum -= nums[leftPos++]; &#125;else&#123; if (rightPos == nums.length)&#123; break; &#125; sum += nums[rightPos++]; &#125; &#125; return length; &#125;&#125;]]></content>
      <categories>
        <category>算法题</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Trapping Rain Water]]></title>
    <url>%2F2019%2F05%2F30%2F%E7%AE%97%E6%B3%95%E9%A2%98%2FTrapping-Rain-Water%2F</url>
    <content type="text"><![CDATA[题目 思路： 拆开来看，判断每个位置还能装多少水，这样每个位置能装的水取决于该位置左右两边的最大值 从左到右扫一遍，得到数组在该位置的左边的最大值（包括这个数） 从右到左扫一遍，得到数组在该位置的右边的最大值（包括这个数） 重新扫一遍数组，判断这个数是否比左边的最大值和右边的最大值小(可以和第二步一起做，减少一次遍历的时间） 12345678910111213141516171819202122232425public static int trap(int[] height)&#123; if (height == null || height.length &lt;= 2)&#123; return 0; &#125; int[] head = new int[height.length]; int[] tail = new int[height.length]; head[0] = height[0]; for (int i = 1; i &lt; height.length; i++)&#123; head[i] = Math.max(head[i-1], height[i]); &#125; tail[height.length - 1] = height[height.length - 1]; for (int i = height.length - 2; i &gt;= 0; i--)&#123; tail[i] = Math.max(tail[i+1], height[i]); &#125; int sum = 0; for (int i = 1; i &lt; height.length - 1; i++)&#123; if (height[i] &lt; head[i] &amp;&amp; height[i] &lt; tail[i])&#123; sum += Math.min(head[i], tail[i]) - height[i]; &#125; &#125; return sum; &#125;]]></content>
      <categories>
        <category>算法题</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UML类图]]></title>
    <url>%2F2019%2F05%2F27%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FUML%E7%B1%BB%E5%9B%BE%2FUML%E7%B1%BB%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[UML：Unified Modeling Language，统一建模语言。是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。 为了更好地读懂和理解设计模式需要学习UML（通过图形分析各个类之间的关系比通过代码更加直观易懂），既然学了UML类图，所以再顺便学了一下如何使用StarUML绘制来绘制UML类图。 绘图工具：开源的StarUML 参考资料：StarUML使用教程 类图主要包括这几个部分：类（Class）、接口（Interface）、双向关联（Association）、单向关联（DirectedAssociation）、聚合关系（Aggregation）、组合关系（Composition）、依赖关系（Dependency）、泛化关系（Generalization）、实现（Realization） StarUML中的类视图选项。先学上面列举的，暂时够用就行。 类视图类视图的表示方法 12345678910public class Person&#123; private int age; public String name; protected String race; public Person()&#123;&#125; public Person(int age, String name, String race)&#123;&#125; public int getAge()&#123; return age; &#125;&#125; 用UML类图表示的Person如下 上面是Attribute，也就是字段（属性），同一行分别表示：访问权限（可见性） 字段名 类型 “-“:private “+”:public “#”:protected “~”:package（默认访问权限） 下方是Operation（应该也可以叫Method），也就是方法。对应的是 访问权限 方法名 返回类型 接口123public interface IShape&#123; double getArea();&#125; 跟类的UML表示方法基本一样，只是上方多了&lt;&lt;&gt;&gt; 类与类的关系双向关联（Association）用不带箭头的实线表示。 老师给多个同学上课，同学有多个老师。 单向关联（DirectedAssociation）用带箭头的实现表示。 顾客的信息包括产品信息，产品信息不包括顾客 聚合关系（Aggregation）常见表示方法：一端带箭头，一端带空心菱形的实线 HAS-A。整体与部分的关系。一个对象作为另一个对象的成员存在，或者说一个对象是另一个对象的一部分。成员是整体对象的一部分，但是成员对象也可以脱离整体对象存在。 引擎是汽车的一部分，所以汽车和引擎是聚合关系。 表示方法似乎有两种，一种带箭头，一种不带箭头 带箭头的用得似乎更多一些？ 组合关系（Composition）常见表示方法：一端带箭头，一端带实心菱形的实线。 整体与部分的关系。但是整体对象可以控制成员对象的生命周期，成员对象与整体是同生共死的关系。 还是用汽车和引擎的例子。 同样是带箭头和不带箭头的画法。 泛化关系（Generalization）用一端带空心三角形的实线表示。 IS-A。直接理解为继承就行 依赖关系（Dependency）用带箭头的虚线表示。 USE-A的关系。一个对象需要使用另一个对象 #类与接口的关系 实现关系（Realization）用一端带空心三角形的虚线表示 实现接口。 扩展各种关系的强弱顺序 泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖 关系的强弱指什么？ 类与类之间的耦合度。可以理解为其中一个类发生变化时对另外一个类的影响程度。 为什么是上面那个顺序？ 这个问题慢慢想。 通过类图寻找关键的类 实体类：实体类对应系统需求中的每个实体，它们通常需要保存在永久存储体中，一般使用数据库表或文件来记录，实体类既包括存储和传递数据的类，还包括操作数据的类。实体类来源于需求说明中的名词，如学生、商品等。 控制类：控制类用于体现应用程序的执行逻辑，提供相应的业务操作，将控制类抽象出来可以降低界面和数据库之间的耦合度。控制类一般是由动宾结构的短语（动词+名词）转化来的名词，如增加商品对应有一个商品增加类，注册对应有一个用户注册类等 边界类：边界类用于对外部用户与系统之间的交互对象进行抽象，主要包括界面类，如对话框、窗口、菜单等。 这个在学习过程中慢慢体会。]]></content>
      <categories>
        <category>-设计模式</category>
      </categories>
      <tags>
        <tag>-设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式README]]></title>
    <url>%2F2019%2F05%2F26%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FREADME%2F</url>
    <content type="text"><![CDATA[说明用于学习设计模式 前置知识 UML类图 设计模式 Iterator(迭代器)模式 Adapter(适配器)模式 Template Method(模版)模式 Factory Method(工厂)模式 Singleton(单例)模式 Prototype(原型)模式 Builder(建造者)模式 Abstract Factory(抽象工厂)模式 Bridge(桥)模式]]></content>
      <categories>
        <category>-设计模式</category>
      </categories>
      <tags>
        <tag>-设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迭代器模式]]></title>
    <url>%2F2019%2F05%2F25%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[hexo自动生成的文章]]></title>
    <url>%2F2019%2F05%2F16%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
