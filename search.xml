<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[RocketMQ总结]]></title>
    <url>%2F2019%2F08%2F11%2FRocketMQ%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[RocketMQ总结这次实习导师给的题目是实现一个延时消息队列，建议使用RocketMQ,在现有的消息队列上进行改动，完成功能。实习也快一个月了，所以就顺便写下来，算是一点总结。也记录一下学习的过程。 RocketMQ是什么阿里提供的开源的中间件，一个存放消息的容器，在2016年捐献给Apache基金会。 用途生产者和消费者的解耦合，异步通信，削峰填谷，消息堆积。 Producer投递完成之后，可以去处理其他逻辑；Consumer会到消息队列中获取消息，完成消费。如此就实现了生产者和消费者的解耦和异步通信。 流量大时，消息队列可以堆积足够多的消息，并且由于消息队列也有落盘机制，所以可以持久化消息。 应用场景 生活中MQ的应用场景。 到饭店用餐的场景，流程大概是这样的：告诉服务员要上的菜——点菜ok——通知后厨——上菜 点菜的人就是生产者，后厨则是消费者，服务员则充当了消息队列。 开发中MQ的使用场景。 以下单流程为例。 RocketMQ架构 如上图分为四个部分，每个部分都可以看成一个集群。就把上图想象成请求淘宝网页和相关数据的方式。 Producer负责生产消息，可以想象成是成千上万台客户端请求的消息。 NameServer路由注册中心，通过NameServer可以知道Broker的路由信息。 BrokerServer负责消息存储、投递、查询的服务器。分为Master Broker和Slave Broker，从字面上容易理解，主从模式，保证高可用。 Consumer消费者，想象成处理来自客户端请求的服务器。 一条消息投递给MQ的过程是这样的：Producer生产一条消息，先问NameServer要放到哪台Broker中，然后得到Broker的地址，再将消息写入到这台Broker中。 消费者从MQ取出消息的过程：Consumer首先询问NameServer从哪台Broker取消息，得到Broker的地址后，再将消息从这台服务器取出。 基本概念Producer生产者，提供了多种发送消息的方式。可以发送同步消息、异步消息、顺序消息、事务消息（4.3.0版本之后） Consumer消费者，有两种消费方式：pull和push。pull是客户端循环地从服务器拉取数据，但需要额外维护consumer的消息；push是服务器主动把消息推给客户端，实时性较高。 Topic消息的主题，发送给订阅的消费者 Tag标记，用于筛选消息。 Group组，消费者有消费者组，生产者有生产者组。 集群消费和广播消费集群消费模式：相同的消费者组中的Consumer平摊所有消息。 广播消费模式：相同的消费者组中的每个Consumer都会收到消息。 消息的存储 CommitLog消息在CommitLog中按顺序存储，来一条消息就往CommitLog上面写，顺序写入，这样做是因为磁盘按顺序读取的速度可以很接近访问内存的速度。 ConsumerQueue上文提到了Topic，这些队列就是基于主题的队列，队列存放的是在CommitLog中的起始位置和偏移量，也可以说是索引。 消息的过滤 通过Topic和Tag进行过滤 可以自定义filter进行消息过滤 延时消息RocketMQ支持延时消息，不过只有18个延时级别，不能自定义延时时长。 事务消息 如上图，正常的流程是：1-&gt;2-&gt;3-&gt;4 但是为了保证消息的可靠提交，引入了补偿机制：5，6，7 为什么引入之后可以保证消息的可靠投递呢？再介绍个Op消息。 Op消息用来标志Half消息的状态，有三种可能，没有Op消息；处于Commit状态；处于Rollback状态。 接下来分析下可能出错的情况就知道如何保证消息的可靠投递了。 1阶段出错，重发即可。 2阶段出错，producer没有收到mq的消息，则会重新投递，而之前投递的消息则会由于失去Op消息而无效。 3出错，则会发送rollback消息 4出错，由于补偿机制，mq会询问producer这条消息的状态，如果能联络，则走6，7步，如果不能，超过重试次数该条消息也就作废。 6，7出错，同上。]]></content>
  </entry>
  <entry>
    <title><![CDATA[《朝闻道》]]></title>
    <url>%2F2019%2F07%2F07%2F%E6%9C%9D%E9%97%BB%E9%81%93%2F</url>
    <content type="text"><![CDATA[朝闻道，夕死可矣。——《论语·里仁》 早晨闻道，晚上就可以为之死去。以前读这句话时没有什么感触，不就是明白道理就可以去死吗？但是大刘将其完美地展示出来：一群对真理有着近乎病态的追求的学者，用生命来换取真理。这群人放弃了其余的追求，没有任何事物可以让他们留恋，他们就像飞蛾扑火一样，只为了享受这一瞬间的光明。 以前难以理解Halo中的先行者牺牲自己的种群，只是为了银河系中其它物种的延续。现在看来，如果一个文明进化到了文章中所提及的高度，整个文明有着共同的信仰和目标，确实有可能作出这样的事情。因为之前难以想象，一个物种牺牲自己只为拯救其它物种，甚至不留下自己的火种。(不太认可这种剧情，因为我认为更为合理的剧情应该是这样的，作死的古人类发明了flood用于战争，结果发现flood难以控制，甚至威胁自身，最终只能与其同归于尽，人类的科技水平重新回到了山顶洞人时代，而所谓的先行者其实就是古人类，百万年之后，人类重新点亮科技树，消灭flood，但是故事情节并没有这样发展…) 星云生物的故事：宇宙中遍布了星云生物，创造了璀璨的文明，经过岁月的沉淀，文明中的所有生物一致同意，进行一次有可能毁灭整个宇宙的实验，而目标就是为了宇宙的真理。获得真理的关键数据是在真空衰变前万分之一秒的时候产生的。而无从猜测星云生物最后是否推导出了宇宙大一统模型，他们仅仅是为了窥见真理就付出了毁灭自身，毁灭整个文明，毁灭整个宇宙的代价。 来自高级文明的排险者，球状的真理祭台，底下是无边的草地，一群为了真理交换生命的学者，一群为了劝说学者不要用生命交换真理而磨破嘴皮的人，一群电视机前的吃瓜群众。这个画面很是悲壮，学者们获得真理之后只能再短暂的存活十分钟，十分钟之后就化为乌有，仿佛它从未来过，但大多数人不也这样吗？忙忙碌碌，寻寻觅觅，最终也是化为腐朽。 宇宙的目的是什么？看到这我也是心头一震，这是个什么问题哦。 &emsp;“博士，您的问题？”排险者问。对霍金，他似乎没有表示出比对其他人更多的尊重。他面带毫无特点的微笑，听着博士轮椅上的扩音器发出的呆板的电子声音：“宇宙的目的是什么？”&emsp;天空中没有答案出现。排险者连上的微笑消失了，他的双眼中掠过了一丝不易觉察的恐慌。&emsp;“先生？”霍金问。&emsp;仍是沉默。天空仍是一片空旷，在地球的几缕薄云后面，宇宙的群星正在浮现。&emsp;“先生？”霍金又问。&emsp;“博士，出口在您后面？”排险者说。&emsp;“这是答案吗？”&emsp;排险者摇摇头，“我是说您可以回去了。”&emsp;“你不知道？”&emsp;排险者点点头说：“我不知道。”这时，他的面容第一次不再是一个图形符号。一片悲哀的黑云罩上这张脸，那样生动和富有个性，以至于谁也不怀疑他是一个人，而且是一个最平常因而最不平常的普通人。 读起来畅快淋漓，又发人深省，提供了多个视角来看待问题，站在人类历史长河的角度看，站在宇宙时空的角度看，这大概就是大刘的小说的魅力吧，将人置身于无穷变换的时空去感受自身的渺小。]]></content>
      <categories>
        <category>码畜的自我修养</category>
      </categories>
      <tags>
        <tag>瞎BB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Map总览2]]></title>
    <url>%2F2019%2F07%2F07%2F%E6%BA%90%E7%A0%81%E4%B9%8B%E6%97%85%2FMap%E6%80%BB%E8%A7%882%2F</url>
    <content type="text"><![CDATA[Hashtable、HashMap、LinkedHashMap、TreeMap Hashtable123public class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable 哈希表。 属性 Entry类123456private static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Entry&lt;K,V&gt; next;&#125; 可以看到有个Entry&lt;K,V&gt; next，所以Hashtable是数组+链表实现的。 构造方法为什么是11呢，可能是取两位数的最小质数？ 放入元素此处看到put方法是线程安全的。 查找元素也是线程安全的。 删除元素线程安全 rehash的实现 扩容方式：翻倍+1。最大不能超过MAX_ARRAY_SIZE。 HashMap12public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable 属性看起来比较复杂，抄下来看懂了再补充1234567891011121314151617181920212223242526272829public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable&#123; //版本号，不必理会 private static final long serialVersionUID = 362498820763181265L; //默认初始化大小 static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 //集合最大的空间 static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; //默认装填因子 static final float DEFAULT_LOAD_FACTOR = 0.75f; static final int TREEIFY_THRESHOLD = 8; static final int UNTREEIFY_THRESHOLD = 6; static final int MIN_TREEIFY_CAPACITY = 64; //存放集合的数据结构，是个数组 transient Node&lt;K,V&gt;[] table; //视图 transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; //集合元素个数 transient int size; //修改次数，用于迭代器 transient int modCount; //阈值 int threshold; //装填因子 final float loadFactor;&#125; 构造函数上面这段代码是将HashMap的数组的大小始终控制在2^i-1，123456int n = cap - 1;n |= n &gt;&gt;&gt; 1;n |= n &gt;&gt;&gt; 2;n |= n &gt;&gt;&gt; 4;n |= n &gt;&gt;&gt; 8;n |= n &gt;&gt;&gt; 16; 第一次让最高位和次高位变成1（最高位自然是1，实际改变第一位），然后改变第三位和第四位的数值为1，以此类推。 元素123456static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next;&#125; 还是一个链表，难道HashMap也是数组+链表实现的吗？ 看到增加元素的时候又看到了这个内部类1234567static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123; TreeNode&lt;K,V&gt; parent; // red-black tree links TreeNode&lt;K,V&gt; left; TreeNode&lt;K,V&gt; right; TreeNode&lt;K,V&gt; prev; // needed to unlink next upon deletion boolean red;&#125; 这是红黑树的节点。 所以：HashMap是数组+链表或者红黑树实现的。但是，我不懂红黑树-_-!! 插个分割线，先去补一下红黑树的知识。 增加一个元素]]></content>
      <categories>
        <category>源码之旅</category>
      </categories>
      <tags>
        <tag>源码之旅</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Set总览2]]></title>
    <url>%2F2019%2F07%2F07%2F%E6%BA%90%E7%A0%81%E4%B9%8B%E6%97%85%2FSet%E6%80%BB%E8%A7%882%2F</url>
    <content type="text"><![CDATA[HashSet、TreeSet、LinkedHashSet到了看起来有点难的Set的具体实现类了 HashSet123public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable 属性HashSet的实现竟然用到了HashMap，有点出乎意料，先往下看看，如果看不懂的话得折回去先把Map这一支看完。##插个分割线，先去看下Map，好像Set绕不开Map？？？##]]></content>
      <categories>
        <category>源码之旅</category>
      </categories>
      <tags>
        <tag>源码之旅</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Set总览1]]></title>
    <url>%2F2019%2F07%2F05%2F%E6%BA%90%E7%A0%81%E4%B9%8B%E6%97%85%2FSet%E6%80%BB%E8%A7%881%2F</url>
    <content type="text"><![CDATA[Set、SortedSet、NavigableSet、AbstractSet 分两次看好了，先看圈出来的部分。虽然面试常问的HashSet和TreeSet，但还是按顺序看比较舒服。 Set这个接口之前看过了，稍微复习一下。1public interface Set&lt;E&gt; extends Collection&lt;E&gt; 不含重复元素的集合，是数学中集合的抽象，最多只有一个空元素。 SortedSet听名字可以猜到代表有序、不可重复的集合。1public interface SortedSet&lt;E&gt; extends Set&lt;E&gt; 这个类比较陌生，截个中文文档的方法摘要。 NavigableSet1public interface NavigableSet&lt;E&gt; extends SortedSet&lt;E&gt; navigable：可航行的。可航行的Set？导航Set？还是看注释吧。 A {@link SortedSet} extended with navigation methods reporting closest matches for given search targets. Methods {@link #lower}, {@link #floor}, {@link #ceiling}, and {@link #higher} return elements respectively less than, less than or equal, greater than or equal, and greater than a given element, returning {@code null} if there is no such element. 嗯，如果没理解错的话，这个接口可以拿来做匹配用。 AbstractSet1public abstract class AbstractSet&lt;E&gt; extends AbstractCollection&lt;E&gt; implements Set&lt;E&gt; 提供了骨架实现，很像是装饰器模式的应用。]]></content>
      <categories>
        <category>源码之旅</category>
      </categories>
      <tags>
        <tag>源码之旅</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Map总览1]]></title>
    <url>%2F2019%2F07%2F05%2F%E6%BA%90%E7%A0%81%E4%B9%8B%E6%97%85%2FMap%E6%80%BB%E8%A7%881%2F</url>
    <content type="text"><![CDATA[Map总览 这个集合很重要，由于Set的几个实现类都用到了Map，所以先来通关Map集合。 Map1public interface Map&lt;K, V&gt; 键值对，它的出现是用来代替Dictionary接口的，等会再去看看Dictionary这个老家伙。Map接口提供了三个集合视图 ，允许将映射的内容视为一组键，值的集合或键值映射集合。 地图的顺序被定义为其中在地图上的集合视图迭代返回元素的顺序。1interface Entry&lt;K, V&gt; 地图条目，代表Map中的一组键值对。 Dictionary1public abstract class Dictionary&lt;K,V&gt; Enumeration类似于迭代器。 AbstractMap1public abstract class AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt; 这也是提供了Map的骨架实现，减少实现Map接口的工作量。 其中提供了一个关键的方法留给子类实现。1public abstract Set&lt;Entry&lt;K,V&gt;&gt; entrySet(); 这个方法返回一个带键值对的集合视图，其它已实现的方法都是在该方法的基础上获得迭代器而得以完成的。 SortedMap1public interface SortedMap&lt;K,V&gt; extends Map&lt;K,V&gt; 看名字可以知道这是一个排好序的Map集合。Map有key和value，那么是按什么样的顺序排序？看下面 A {@link Map} that further provides a total ordering on its keys. The map is ordered according to the {@linkplain Comparable natural ordering} of its keys, or by a {@link Comparator} typically provided at sorted map creation time. 提供的方法和SortedSet差不多 NavigableMap1public interface NavigableMap&lt;K,V&gt; extends SortedMap&lt;K,V&gt; 这个和NavigableSet一样！提供了返回给定目标的最近搜索匹配。]]></content>
      <categories>
        <category>源码之旅</category>
      </categories>
      <tags>
        <tag>源码之旅</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Queue总览]]></title>
    <url>%2F2019%2F07%2F03%2F%E6%BA%90%E7%A0%81%E4%B9%8B%E6%97%85%2FQueue%E6%80%BB%E8%A7%88%2F</url>
    <content type="text"><![CDATA[队列总览队列也属于线性表，前面把List看了，所以接着看队列顺序应该不会错。 ArrayDeque双端队列。1public class ArrayDeque&lt;E&gt; extends AbstractCollection&lt;E&gt; implements Deque&lt;E&gt;, Cloneable, Serializable 注释很有用 Resizable-array implementation of the {@link Deque} interface. Array deques have no capacity restrictions; they grow as necessary to support usage. They are not thread-safe; in the absence of external synchronization, they do not support concurrent access by multiple threads. Null elements are prohibited. This class is likely to be faster than {@link Stack} when used as a stack, and faster than {@link LinkedList} when used as a queue. 关键信息：可以动态增长；非线程安全，所以不支持并发；不允许插入空元素；用作堆栈时速度可能比Stack快，用作队列时速度可能比LinkedList快。 Stack是线程安全的，速度比Stack快容易理解。但是速度比LinkedList快是怎么回事？ 啊，对，因为ArrayDeque是数组存储的，所以没有额外的结构性开销，而LinkedList是链式存储的，找到下一个元素的位置可能更加耗时。 ArrayDeque属性 构造方法可以看到不指定大小时默认分配16个位置。这里看到会多分配一个元素，可能是考虑到了假溢出的问题。那就看看增删改查是怎么回事。 增加一个元素看来没考虑假溢出的问题，可能在普通队列有？addFirst可以看成是从数组的右端开始放置元素，addLast可以看成是从数组的左端开始放置元素。 这里有个地方要注意，head和tail的修改方式是不同的。 这是addFirst方法，先修改head，然后添加元素，再判断head==tail。所以head指向当前的头元素。1234es[head = dec(head, es.length)] = e;if (head == tail)&#123; grow(1);&#125; 这是addLast方法，先添加，然后修改tail，再判断head==tail，所以tail指向尾元素的下一个元素123es[tail] = e;if (head == (tail = inc(tail, es.length))) grow(1); 删除一个元素 对于队列来说，没有修改某个元素的说法？因为只提供了操作头尾元素的方法 扩容方式注释写得很清楚了，队列比较小的时候翻倍，比较大的时候扩容50%。但是实际上是队列比较小的时候翻倍+2 AbstractQueue12345678910/** * This class provides skeletal implementations of some &#123;@link Queue&#125; * operations. The implementations in this class are appropriate when * the base implementation does &lt;em&gt;not&lt;/em&gt; allow &#123;@code null&#125; * elements. Methods &#123;@link #add add&#125;, &#123;@link #remove remove&#125;, and * &#123;@link #element element&#125; are based on &#123;@link #offer offer&#125;, &#123;@link * #poll poll&#125;, and &#123;@link #peek peek&#125;, respectively, but throw * exceptions instead of indicating failure via &#123;@code false&#125; or * &#123;@code null&#125; returns. * PriorityQueue优先队列，采用Priority Heap实现。底层采用数组实现，先猜一下，可能是通过上滤和下滤的方式实现。12public class PriorityQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements java.io.Serializable PriorityQueue属性如果没有传入Comparator的话，要求集合元素实现Comparable接口。 增加一个元素两种方式都一样，这里只放其中一个。通过上面也可以看出PriorityQueue是小顶堆，元素小的放在上面。 取出堆顶元素先取出堆顶元素，接着把末尾元素放入堆顶，然后进行下滤。同样提供两个选择 扩容方式集合元素个数小于64时，乘2再加2；大于64时，乘1.5]]></content>
      <categories>
        <category>源码之旅</category>
      </categories>
      <tags>
        <tag>源码之旅</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型(Prototype)模式]]></title>
    <url>%2F2019%2F06%2F30%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[原型模式概述原型模式通过复制一个对象来得到一个新的实例，就像是克隆一样。工作原理也是克隆，通过目前已有的实例获得另一个一模一样的实例。 原型模式 使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。 组成 抽象原型类(Prototype)：声明了克隆方法的接口或抽象类。 具体原型类(ConcretePrototype)：实现抽象原型类的接口。 抽象原型类就是孙悟空的毫毛，具体原型类就是一个又一个的孙悟空。 例子抽象原型类12public interface Cloneable &#123;&#125; 具体原型类12345678class Dolly implements Cloneable&#123; Dolly()&#123;&#125; @Override public Dolly clone() throws CloneNotSupportedException &#123; Object obj = super.clone(); return (Dolly)obj; &#125;&#125; 使用123456public static void main(String[] args) throws CloneNotSupportedException &#123; Dolly dolly1 = new Dolly(); Dolly dolly2 = dolly1.clone(); //输出结果为false System.out.println(dolly1 == dolly2);&#125; 这个类图太简单了就不画了。 原型模式的优点 简化创建实例的过程，可以提高创建实例的效率。这是针对创建实例过程复杂的情况而言的。 与工厂类相比，原型模式不需要专门的工厂来创建实例。 提供了抽象接口，客户端可以修改配置文件使用不同的原型类。 原型模式的缺点 实现深克隆时需要更加复杂的代码，而且每一层对象的类都必须支持深克隆，实现起来可能比较麻烦。 原型模式 原型模式的适用场景 创建新对象的成本较大(占用过多CPU资源、网络资源等) 资源优化 深克隆和浅克隆浅克隆原型对象的成员变量是引用类型，则将引用类型的成员变量赋值一份给克隆对象，这样克隆对象和原型对象的成员变量实际上是同一个。123456789101112131415161718class Prototype implements Cloneable&#123; private int[] array = new int[10]; Prototype()&#123;&#125; @Override public Prototype clone() throws CloneNotSupportedException &#123; return (Prototype) super.clone(); &#125; public int[] getArray()&#123; return array; &#125;&#125;public static void main(String[] args) throws CloneNotSupportedException &#123; Prototype prototype = new Prototype(); Prototype clone = prototype.clone(); System.out.println(prototype == clone); System.out.println(prototype.getArray() == clone.getArray());&#125; 输出结果12falsetrue 深克隆自然是与浅克隆相反了，所有的成员变量都会进行克隆。如果成员变量是引用类型的，并且该成员变量的成员变量也有引用类型的，那么就构成了引用的嵌套，处理起来比较麻烦。可以通过序列化等方式实现深克隆。 1234567891011121314151617181920212223242526272829303132class Prototype implements Serializable,Cloneable&#123; int[] array = new int[10]; @Override public Prototype clone()&#123; try &#123; //将对象写入流中 ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream); objectOutputStream.writeObject(this); //将对象从流中读出 ByteArrayInputStream inputStream = new ByteArrayInputStream(outputStream.toByteArray()); ObjectInputStream objectInputStream = new ObjectInputStream(inputStream); return (Prototype) objectInputStream.readObject(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return null; &#125; public int[] getArray()&#123; return array; &#125;&#125;public static void main(String[] args) throws CloneNotSupportedException &#123; Prototype prototype = new Prototype(); Prototype clone = prototype.clone(); System.out.println(prototype == clone); System.out.println(prototype.getArray() == clone.getArray());&#125; 结果是12falsefalse]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lis总览2]]></title>
    <url>%2F2019%2F06%2F30%2F%E6%BA%90%E7%A0%81%E4%B9%8B%E6%97%85%2FList%E6%80%BB%E8%A7%882%2F</url>
    <content type="text"><![CDATA[Vector、ArrayList、LinkedList、Stack前面把前置的类和接口捋一遍了，现在尝试读一下这几个重要的集合。 Vector这是一个元老级别的类了，从jdk1.0开始就存在至今。123public class Vector&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 虽然还实现了Cloneable和Serializable接口，不过这两个接口都是标记接口，不用管它。 Vector的属性 Vector是用数组实现的，没有传参的话默认是分配10个空间大小 Vector的增删会移动整个数组 Vector扩容a. 如果指定了capacityIncrement，每次就增加capacityIncrement个位置b. 如果没有指定，每次都会翻一倍 1234567891011121314private int newCapacity(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); if (newCapacity - minCapacity &lt;= 0) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return minCapacity; &#125; return (newCapacity - MAX_ARRAY_SIZE &lt;= 0) ? newCapacity : hugeCapacity(minCapacity);&#125; Vector的线程安全 Vector是线程安全的。增删改方法都加上了synchronized关键字 12345678public synchronized boolean add(E e)public synchronized void addElement(E obj)public synchronized boolean removeElement(Object obj)public synchronized boolean removeElement(Object obj)public synchronized void removeAllElements()public synchronized E set(int index, E element)public synchronized void setElementAt(E obj, int index)public synchronized E get(int index) Vector的迭代器 1234567891011public synchronized ListIterator&lt;E&gt; listIterator(int index) &#123; if (index &lt; 0 || index &gt; elementCount) throw new IndexOutOfBoundsException(&quot;Index: &quot;+index); return new ListItr(index);&#125;public synchronized ListIterator&lt;E&gt; listIterator() &#123; return new ListItr(0);&#125;public synchronized Iterator&lt;E&gt; iterator() &#123; return new Itr();&#125; 迭代器的查找和删除都是线程安全的，如果有两个迭代器对同一个Vector进行遍历，在遍历过程中有一个迭代器对Vector进行了删除操作，会导致modCount与迭代器的expectedModCount不一致而抛出异常。 ArrayList12public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 属性123456789101112131415private static final long serialVersionUID = 8683452581122892189L;private static final int DEFAULT_CAPACITY = 10;private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;transient Object[] elementData;private int size;private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 可以看到ArrayList也是用数组存储数据，一开始的默认大小为10，并且提供两个空的数组用来初始化elementData。 扩容方式也就是扩容为原来的1.5倍 增删会移动整个数组 线程不安全 LinkedList123public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable 内部的节点，可以看出是双链表。 属性 构造函数 123456public LinkedList() &#123;&#125;public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c);&#125; 调用空参构造器时，内部结点默认为null，没有在链表的首尾加哨兵。 增加 查找 删除 修改=查找 实现Deque接口的增删改方法和实现List接口的增删改方法其实都一样。 复杂度分析 增加元素：如果指定了位置，则复杂度为O(n)；否则，复杂度为O(1) 查找元素：O(n) 删除元素：删除指定位置为O(n)，删除头结点和尾结点为O(1) Stack和Vector一样是个元老，从jdk1.0开始存在至今。看完Vector应该就看Stack的，阅读顺序不太对。1public class Stack&lt;E&gt; extends Vector&lt;E&gt; 总览 线程安全继承自Vector，并且push、pop、peek等方法都使用了Vector的方法，如果没有，也加了synchronized关键字修饰。所以是线程安全的。 扩容方式和Vector一样，每次乘2。 Vector、Stack、ArrayList、LinkedList比较 实现方式 扩容方式 线程安全 初始大小 集合能否有空元素 Vector 数组 没有指定就变为原来的2倍 安全 没有指定的话默认是10个 可以 Stack 数组 和Vector爸爸一样 安全 10个 可以 ArrayList 数组 变为原来的1.5倍 不安全 没有指定的话默认是10个 可以 LinkedList 双链表 链表没有扩容的说法 不安全 0个 结点元素的数据可以为空 ArrayList和LinkedList复杂度比较 增加 删除 修改 查找 ArrayList 加在末尾为O(1)，指定下标为O(n) O(n) 只提供了通过索引的方式修改，所以复杂度为O(1)，但是我想O(n)会合理一点 O(n) LinkedList 和ArrayList一样 O(n) O(n) O(n)]]></content>
      <categories>
        <category>源码之旅</category>
      </categories>
      <tags>
        <tag>源码之旅</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[List总览1]]></title>
    <url>%2F2019%2F06%2F30%2F%E6%BA%90%E7%A0%81%E4%B9%8B%E6%97%85%2FList%E6%80%BB%E8%A7%881%2F</url>
    <content type="text"><![CDATA[List集合List是有序集合，允许放置重复的元素，实现的方式有数组和链表。接下来看几个直接或间接了实现该接口的类。当然不可避免地要看继承了其它的类的源码。 AbstractCollectionpublic abstract class AbstractCollection&lt;E&gt; implements Collection&lt;E&gt; 为什么MAX_ARRAY_SIZE需要减8呢？ The maximum size of array to allocate. Some VMs reserve some header words in an array. Attempts to allocate larger arrays may result in OutOfMemoryError: Requested array size exceeds VM limit 理论上说最大值是Integer.MAX_VALUE-8，但在hugeCapacity()方法中也允许超过这个值，使用Integer.MAX_VALUE。 12345678private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError (&quot;Required array size too large&quot;); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 这个有点像是装饰器模式，继承了这个接口，而更具体的方法则交给具体类去完成。 为什么会有私有静态方法？先跳过，接着往下看。 RandomAccess因为AbstracList中的内部类继承了这个接口，所以先看一下。然后发现这是个标记接口，空空如也。也是为了支持并行而出现的。 用处： Marker interface used by {@code List} implementations to indicate that they support fast (generally constant time) random access. The primary purpose of this interface is to allow generic algorithms to alter their behavior to provide good performance when applied to either random or sequential access lists. ListIterator前面画图漏掉这个迭代器了，现在补一下。 这是一个用于迭代List的迭代器吧。public interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; AbstractListpublic abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; 让人好奇的是分别提供了ListIterator和Iterator，为什么需要提供两种迭代器？1234Iteratorpublic Iterator&lt;E&gt; iterator() &#123; return new Itr();&#125; 123456ListIteratorpublic ListIterator&lt;E&gt; listIterator(final int index) &#123; rangeCheckForAdd(index); return new ListItr(index);&#125; 提供的保护变量protected int modCount用于标记是否修改过。 AbstractSequentialListpublic abstract class AbstractSequentialList&lt;E&gt; extends AbstractList&lt;E&gt; 这个类可以用来随机访问集合中的元素，同时支持并行处理。 This class provides a skeletal implementation of the interface to minimize the effort required to implement this interface backed by a “sequential access” data store (such as a linked list). For random access data (such as an array), should be used in preference to this class. 可以看到它提供了通过下标访问元素的方式。 Deque双端队列。还不清楚为什么LinkedList会实现这个接口，可能因为LinkedList是双链表实现的吧。 public interface Deque&lt;E&gt; extends Queue&lt;E&gt; 除了提供Queue和Collection的方法外，Deque还提供了一些方法便于对队列的两端进行操作。 前置的类和接口大概捋一遍了，接下来可以看重点了。]]></content>
      <categories>
        <category>源码之旅</category>
      </categories>
      <tags>
        <tag>源码之旅</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建造者(Builder)模式]]></title>
    <url>%2F2019%2F06%2F25%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[建造者模式概述建造者模式属于创建型模式，客户端所需的对象包含复杂的创建过程，建造者模式将其分离，使得客户端无需关心对象的创建过程。 建造者模式 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 听名字可以联想到建筑，想住新房子只要交钱就行了，不用知道房子是怎么盖的。 组成 抽象建造者(Builder)：为创建一个产品的各个部件指定接口。 具体建造者(ConcreteBuilder)：实现抽象建造者的接口。 产品(Product)：需要生产的目标对象。 指挥者(Director)：指导具体建造者按什么步骤构建产品。 抽象建造者可以类比为一张杂乱无章的图纸，上面写满了生产一件产品要做的事情。 具体建造者也可以类比为一张杂乱无章的图纸，但是上面写满了如何完成每件事情。 而指挥者可以类比为整理过的图纸，纸上将各个步骤的先后顺序理清楚，排好序。 而产品就是按图纸的步骤完成之后生产出来的产品。 例子从上面可以看出，建造者模式适合一组生产流程相同的情况，这样便于以后的扩展，因此用汉堡包举例子(因为汉堡就是上下两块面包，中间夹个不一样的东西)。 产品1234567891011121314151617181920212223242526272829public class Hamburger &#123; private String upper; private String middle; private String lower; public String getUpper() &#123; return upper; &#125; public void setUpper(String upper) &#123; this.upper = upper; &#125; public String getMiddle() &#123; return middle; &#125; public void setMiddle(String middle) &#123; this.middle = middle; &#125; public String getLower() &#123; return lower; &#125; public void setLower(String lower) &#123; this.lower = lower; &#125;&#125; 抽象建造者123456789101112public abstract class HamburgerBuilder&#123; protected Hamburger hamburger = new Hamburger(); abstract void buildUpper(); abstract void buildMiddle(); abstract void buildLower(); Hamburger createHamburger()&#123; return hamburger; &#125;&#125; 具体建造者123456789101112131415161718192021222324252627282930313233public class BeefHamburgerBuilder extends HamburgerBuilder&#123; @Override void buildUpper() &#123; hamburger.setUpper(&quot;面包&quot;); &#125; @Override void buildMiddle() &#123; hamburger.setMiddle(&quot;牛肉&quot;); &#125; @Override void buildLower() &#123; hamburger.setLower(&quot;面包&quot;); &#125;&#125;public class ChickenHamburgerBuilder extends HamburgerBuilder&#123; @Override public void buildUpper() &#123; hamburger.setUpper(&quot;面包&quot;); &#125; @Override public void buildMiddle() &#123; hamburger.setMiddle(&quot;鸡肉&quot;); &#125; @Override public void buildLower() &#123; hamburger.setLower(&quot;面包&quot;); &#125;&#125; 指挥者(按一定顺序造出汉堡)123456789public class HamburgerController &#123; public Hamburger createHamburger(HamburgerBuilder builder) &#123; builder.buildUpper(); builder.buildMiddle(); builder.buildLower(); return builder.createHamburger(); &#125;&#125; 使用1234567public class User &#123; //假设从配置文件中读取类的信息 HamburgerBuilder builder = XML.getBeans(&quot;builder&quot;); HamburgerController controller = XML.getBean(&quot;controller&quot;); Hamburger hamburger = controller.createHamburger(builder); &#125;&#125; 来看一下UML 建造者模式的优点 客户不需要知道产品内部的组成细节。产品的创建与产品本身解耦，相同的过程可以创建不同的产品。 每一个建造者都相对独立，只要建造模式都差不多就行，所以可以很方便地增加和替代具体建造者，由于是面向接口编程，因此类库不必修改，而客户端只要修改配置文件即可。 建造者模式的缺点 要求产品有较多的共同点，使用范围受到限制。 如果产品经常变化，可能就需要很多地具体建造者来实现这些变化，导致系统变得十分庞大。 建造者模式适用场景 产品的内部结构差不多，建造过程也差不多。 生成的产品有顺序要求。 创建过程和产品分离。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合总览]]></title>
    <url>%2F2019%2F06%2F24%2F%E6%BA%90%E7%A0%81%E4%B9%8B%E6%97%85%2F%E9%9B%86%E5%90%88%E6%80%BB%E8%A7%88%2F</url>
    <content type="text"><![CDATA[阅读的思路用IDEA自动生成UML类图的工具生成了java.util.*包中的所有关系，大概如下图 把异常和看起来没啥用的东西抠掉之后，大概变成下面这样子，看起来是不是干净多了？ 然后该怎么读呢？说实话我也没经验，所以就先从老大接口看起了。具体来说，是下面这几个。 Collection接口代表一组对象的集合，但是并不关心这些对象是有序的还是无序的，可重复的还是不可重复的，这个接口定义了所有集合的通用方法，用于传递给子接口或子类实现。 声明1public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; 这是用到了迭代器模式，用于提供一个统一的遍历集合的方式。 定义的方法看名字就很容易理解了。 只是有个spliterator不知道干嘛的。接着看1234@Overridedefault Spliterator&lt;E&gt; spliterator() &#123; return Spliterators.spliterator(this, 0);&#125; JDK8开始允许接口实现方法，不过方法名之前需要用default修饰。 看起来是调用了Spliterators的静态方法，生成一个迭代器？spliterator是JDK1.8提供的用于并行化的一个接口。 A Spliterator may also partition off some of its elements (using trySplit()) as another Spliterator, to be used in possibly-parallel operations. Operations using a Spliterator that cannot split, or does so in a highly imbalanced or inefficient manner, are unlikely to benefit from parallelism. Traversal and splitting exhaust elements; each Spliterator is useful for only a single bulk computation. 这个目前不重要，可以先跳过。 List接口public interface List&lt;E&gt; extends Collection&lt;E&gt; 有序集合，可以放入重复的元素。实现方式有数组和链接方式吧。 大多数方法看名字也就清楚了，也提供了获取spliterator的方法。 还有这些看不懂，让人疑惑的of方法，是在jdk1.9才提供的。注释说是为了返回不可变的List。跳过。 Set接口public interface Set&lt;E&gt; extends Collection&lt;E&gt; 不可重复集合。有序和无序则取决于实现类的访问方式了，也就是迭代器的访问方式。能不能加入空元素也要看具体的类了。应该是用树形结构实现的。提供的方法和List，Collections大同小异，就不截图了。 Queue接口public interface Queue&lt;E&gt; extends Collection&lt;E&gt; 队列。支持从头部取出数据。以及为插入数据和取出数据提供了成对的方法，有些为空会抛出异常，有些不会。为什么这么设计呢？提供两种方法实现一个相同的功能？可能是为了用于某些需要抛出异常的场合？（比如中断线程之类的） Map接口public interface Map&lt;K, V&gt; 映射。将键映射到值的对象，不能包含重复的键，每个键只能映射到一个值。 Map接口内部还定义了一个接口，不过是换了一个名字的Map接口。 interface Entry&lt;K, V&gt; 这个接口是干嘛的呢？先看Map提供的一个函数：Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();该方法返回Set集合，集合的元素类型是Entry，而存放的元素就是Map集合中的元素。这个方法可以方便地获取Map集合中的所有键值对。]]></content>
      <categories>
        <category>源码之旅</category>
      </categories>
      <tags>
        <tag>源码之旅</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象工厂模式]]></title>
    <url>%2F2019%2F06%2F18%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[抽象工厂模式概述工厂模式中每个工厂只负责生产一个产品，这样会存在很多的工厂类，增加系统的开销。而我们希望一个工厂不止负责生产一个产品，而是生产一类产品，例如一个生产电脑硬件的工厂，可以生产各种硬件，CPU、RAM、GPU，而不是针对每个硬件各自定义一个工厂。这样更加便于管理，提高效率，从逻辑上来说也符合实际情况。 定义：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 我们可以根据厂商的不同来定义不同的工厂，例如可以分为Intel工厂和AMD工厂。 组成 抽象工厂。定义了创建产品的方法。 抽象产品。 具体工厂。实现了创建产品的方法。 具体产品。 例子抽象工厂12345public interface Factory &#123; CPU createCPU(); GPU createGPU(); RAM createRAM();&#125; 抽象产品123456789public interface CPU &#123; void useCPU();&#125;public interface GPU &#123; void useGPU();&#125;public interface RAM &#123; void useRAM();&#125; 具体工厂1234567891011121314151617181920212223242526272829303132public class AMDFactory implements Factory&#123; @Override public CPU createCPU() &#123; return new AMDCPU(); &#125; @Override public GPU createGPU() &#123; return new AMDGPU(); &#125; @Override public RAM createRAM() &#123; return new AMDRAM(); &#125;&#125;public class IntelFactory implements Factory&#123; @Override public CPU createCPU() &#123; return new IntelCPU(); &#125; @Override public GPU createGPU() &#123; return new IntelGPU(); &#125; @Override public RAM createRAM() &#123; return new IntelRAM(); &#125;&#125; 具体产品1234567891011121314151617181920212223242526272829303132333435363738//AMD系列public class AMDCPU implements CPU&#123; @Override public void useCPU() &#123; System.out.println(&quot;I am AMDCPU&quot;); &#125;&#125;public class AMDGPU implements GPU&#123; @Override public void useGPU() &#123; System.out.println(&quot;I am AMDGPU&quot;); &#125;&#125;public class AMDRAM implements RAM&#123; @Override public void useRAM() &#123; System.out.println(&quot;I am AMDRAM&quot;); &#125;&#125;//Intel系列public class IntelCPU implements CPU&#123; @Override public void useCPU() &#123; System.out.println(&quot;I am IntelCPU&quot;); &#125;&#125;public class IntelGPU implements GPU&#123; @Override public void useGPU() &#123; System.out.println(&quot;I am IntelGPU&quot;); &#125;&#125;public class IntelRAM implements RAM&#123; @Override public void useRAM() &#123; System.out.println(&quot;I am IntelRAM&quot;); &#125;&#125; 使用12345678910111213141516171819public class User &#123; public static void main(String[] args) &#123; Factory factory = new IntelFactory(); CPU cpu = factory.createCPU(); GPU gpu = factory.createGPU(); RAM ram = factory.createRAM(); cpu.useCPU(); gpu.useGPU(); ram.useRAM(); factory = new AMDFactory(); cpu = factory.createCPU(); gpu = factory.createGPU(); ram = factory.createRAM(); cpu.useCPU(); gpu.useGPU(); ram.useRAM(); &#125;&#125; UML类图 同样的，可以进一步解耦，根据配置文件读入需要生成的工厂类和产品类，而不是在User方法中使用代码实现（但是都差不多）。 抽象工厂模式优点 隔离了子类的具体生成，客户端不需要知道具体创建了哪个产品。 如果一个工厂中的产品是一个系列，并且被设计为一起工作的，那么这种设计模式可以保证用户始终使用了同一个工厂生产的产品。（比如是某个企业的粉丝，非该企业产品不用） 增加新的产品很方便，不需要修改已有的系统，符合开闭原则。（例如有一家CZQ企业崛起了，同样想生产CPU，GPU和RAM，这时候新建一个具体工厂类和三个具体产品类即可） 抽象工厂模式缺点如果一家工厂不满足生产现有的产品，还想生产新的产品，则需要对整个系统做较大地改动。例如Factory还想生产显示器，那么从头到脚都得改了，如果客户端也想使用新的产品类，那么也必须进行修改。从这个角度来说，不符合开闭原则。 使用场景 产品的结构稳定，系统设计完成之后不会有向系统中增加新的产品或者删除已有产品的行为。 系统中有多于一个系列的产品，而每次只使用其中的一个系列。（例如有Intel和AMD，但是每次只会用Intel的） 属于同一个系列的产品会一起使用，这个约束必须在系统设计中体现出来。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单工厂模式]]></title>
    <url>%2F2019%2F06%2F18%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[简单工厂模式概述简单工厂模式属于创建型模式，创建型模式关注对象的创建过程，关注如何将对象的创建和使用分离，让用户在使用对象时无需关心对象的创建细节，从而降低系统耦合度。 简单工厂模式 定义一个工厂类，可以根据参数的不同返回不同的类的实例，被创建的实例通常有共同的父类。 也就是我们可以根据产品的名称选择需要的产品。例如有个水果工厂(今年的水果价格飞起)，可以站在工厂门口大喊“苹果”，工厂就会生产苹果给你，再喊“西瓜”，就会给你提供西瓜，而你不需要关心这些水果怎么来的。 组成 Factory：工厂角色，工厂模式的核心，负责创建产品，一般对外提供静态工厂方法 Product：抽象产品角色，所有产品类的父类，封装了产品的公有方法 ConcreteProduct：具体产品角色 例子假设有个生产车的工厂，可以生产Car和Bike，根据产品名进行生产。1234567891011121314151617181920212223242526272829303132333435public class AbstractFactoryDemo&#123; public static void main(String[] args) &#123; Factory factory = new Factory(); Product p = factory.createProduct(&quot;Bike&quot;); p.drive(); &#125;&#125;interface Product&#123; void drive();&#125;class Car implements Product&#123; @Override public void drive()&#123; System.out.println(&quot;Car...tututu&quot;); &#125;&#125; class Bike implements Product&#123; @Override public void drive()&#123; System.out.println(&quot;Bike...tututu&quot;); &#125;&#125;class Factory&#123; public static Product createProduct(String name)&#123; if (&quot;Car&quot;.equals(name))&#123; return new Car(); &#125;else if (&quot;Bike&quot;.equals(name))&#123; return new Bike(); &#125; return null; &#125;&#125; UML类图 简单工厂模式优点 可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品的职责，客户端仅仅是使用产品，因此简单工厂模式体现了创建和使用的分离。 只需要具体类对应的参数就可以生成产品。例如例子中只需要知道”Car”参数对应生成一个Car类就行。 通过配置文件，可以在不修改客户端代码的情况下更换和增加新的产品类。 缺点 只有一个工厂类，所以工厂类承担了所有创建产品的逻辑，一旦受到影响，整个系统都不能正常工作。 每次需要添加一个产品时都必须修改工厂类，系统扩展困难，即违反了开闭原则。 由于使用静态工厂方法，因此工厂角色无法形成继承的等级结构。 使用场景 工厂类负责创建的对象比较少，由于对象比较少，业务逻辑不会过于复杂。 客户端不关心如何创建对象。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Russian Doll Envelopes]]></title>
    <url>%2F2019%2F06%2F18%2F%E7%BB%83%E4%B8%80%E7%BB%83%EF%BC%9F%2FRussian-Doll-Envelopes%2F</url>
    <content type="text"><![CDATA[思路 按宽度从小到大排序，宽度相同，则按高度从小到大排序(这个虽然不太准确，因为题目没有给定哪个角标代表宽度)，这时候问题就转换成了：寻找一个最长的递增子序列。 以下是O(n^2)的解法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public static int maxEnvelopes(int[][] envelopes)&#123; if (envelopes == null || envelopes.length == 0)&#123; return 0; &#125; node[] nodes = new node[envelopes.length]; for (int i = 0; i &lt; envelopes.length; i++)&#123; nodes[i] = new node(envelopes[i][0], envelopes[i][1]); &#125; /** * 按宽度从小到大排好序 * 宽度相等，则按高度从小到大排序 */ Arrays.sort(nodes, new Comparator&lt;node&gt;()&#123; @Override public int compare(node n1, node n2)&#123; if (n1.width != n2.width)&#123; return n1.width - n2.width; &#125; return n1.height - n2.height; &#125; &#125;); //dp[i]表示以nodes[i]结尾的套娃个数 int[] dp = new int[nodes.length]; dp[0] = 1; Arrays.fill(dp, 1); for (int i = 1; i &lt; nodes.length; i++)&#123; for (int j = 0; j &lt; i; j++)&#123; if (nodes[i].width &gt; nodes[j].width &amp;&amp; nodes[i].height &gt; nodes[j].height)&#123; dp[i] = Math.max(dp[i], dp[j] + 1); &#125; &#125; &#125; int result = 0; for (int i = 0; i &lt; nodes.length; i++)&#123; result = Math.max(result, dp[i]); &#125; return result;&#125;class node&#123; int width; int height; node(int width, int height)&#123; this.width = width; this.height = height; &#125; node()&#123;&#125;&#125; 和最长递增子序列一样，这题也有O(nlogn)的解法，思路也差不多。用dp[i]表示长度为i的子序列末尾的最小值。 但是这里需要注意排序方式，为了使后面的套娃能够替换前面的套娃，宽度按从小到大排序，高度按从大到小排序。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public static int maxEnvelopes(int[][] envelopes)&#123; if (envelopes == null || envelopes.length == 0)&#123; return 0; &#125; /** * 按宽度从小到大排序 * 宽度相同，则高度按从大到小排序 */ Arrays.sort(envelopes, new Comparator&lt;int[]&gt;()&#123; @Override public int compare(int[] n1, int[] n2)&#123; if (n1[0] != n2[0])&#123; return n1[0] - n2[0]; &#125; return n2[1] - n1[1]; &#125; &#125;); //dp[i]表示长度为i+1的子序列的最小高度值 int[] dp = new int[envelopes.length]; int index = 0; dp[0] = envelopes[0][1]; index += 1; for (int i = 1; i &lt; envelopes.length; i++)&#123; if (envelopes[i][1] &gt; dp[index-1])&#123; //此处不用判断宽度 //宽度相同 -&gt; if条件不可能成立 //宽度不同 -&gt; 由于是按宽度升序排序，所以一定可以可以套住前面的套娃 dp[index++] = envelopes[i][1]; &#125;else&#123; int l = 0, r = index; while (l &lt; r)&#123; int mid = (l + r) &gt;&gt;&gt; 1; if (dp[mid] &gt; envelopes[i][1])&#123; r = mid; &#125;else if (dp[mid] &lt; envelopes[i][1])&#123; l = mid + 1; &#125;else&#123; l = mid; break; &#125; &#125; dp[l] = envelopes[i][1]; &#125; &#125; return index;&#125;]]></content>
      <categories>
        <category>练一练？</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>LIS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Search in Rotated Sorted Array]]></title>
    <url>%2F2019%2F06%2F14%2F%E7%BB%83%E4%B8%80%E7%BB%83%EF%BC%9F%2FSearch-in-Rotated-Sorted-Array%2F</url>
    <content type="text"><![CDATA[进阶版 没什么状态，写写题解捋一捋思路。 这题增加了数组可能出现重复元素的情况，与前一题相比会有什么影响呢？主要的影响是搜索区间的判定，如果重复元素没有出现在端点，那么判断情况和前一题一样。如果出现在端点，会有几种情况？ 思路：二分查找，不断缩小区间。 假设有两个指针left和right分别指向区间的左端点和右端点，数组名为int[] nums。 nums[mid] &gt; nums[left] （用高度来表示数组元素的相对大小，应该是离散的点，但是不要在意这些画图细节）这种情况如果target要么在mid的左侧，要么在mid的右侧。 12345if (target &lt; nums[mid] &amp;&amp; target &gt; nums[left])&#123; //搜索左侧区间 &#125;else&#123; //搜索右侧区间&#125; nums[mid] &lt; nums[left] 这种情况target也是要么在mid的左侧要么在右侧。 12345if (target &gt; nums[mid] &amp;&amp; target &lt; nums[right])&#123; //搜索右侧区间&#125;else&#123; //搜索左侧区间&#125; nums[mid] == nums[left] 这种情况最棘手，因为难以根据nums[mid]与target的大小关系判断要搜索的区间，为什么呢，画几种情况就清楚了。 所以在mid的左右都有存在target的可能。边界情况很复杂，所以直接将左指针右移一次。 123if (nums[mid] == nums[left])&#123; left += 1;&#125; 123456789101112131415161718192021222324252627public static boolean search(int[] nums, int target)&#123; int left = 0, right = nums.length; while (left &lt; right)&#123; int mid = (left + right) &gt;&gt;&gt; 1; if (nums[mid] == target)&#123; return true; &#125; if (nums[left] &lt; nums[mid])&#123; if (target &lt;= nums[mid] &amp;&amp; target &gt;= nums[left])&#123; right = mid; &#125;else&#123; left = mid + 1; &#125; &#125;else if (nums[left] &gt; nums[mid])&#123; if (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right-1])&#123; left = mid + 1; &#125;else&#123; right = mid; &#125; &#125;else&#123; left += 1; &#125; &#125; return false;&#125;]]></content>
      <categories>
        <category>练一练？</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性表]]></title>
    <url>%2F2019%2F06%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E7%BA%BF%E6%80%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[线性表线性表是最简单的数据结构，]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Find Minimum in Rotated Sorted Array]]></title>
    <url>%2F2019%2F06%2F12%2F%E7%BB%83%E4%B8%80%E7%BB%83%EF%BC%9F%2FFind-Minimum-in-Rotated-Sorted-Array%2F</url>
    <content type="text"><![CDATA[递归解法思路：递归加二分。 如果中间元素的值大于左边的元素，那么最小值在右边。（说明该数组经过rotate，大的数跑到前面了） 如果中间元素的值小于左边的元素，那么最小值在左边。（后面的元素肯定比这个中间元素大） 注意边界的处理，上面说的两种情况只适合经过rotate的数组，所以需要先判断该数组是否经过rotate 12345678910111213141516171819202122232425262728293031323334public static int findMin(int[] nums)&#123; if (nums == null || nums.length == 0)&#123; return 0; &#125; if (nums.length == 1)&#123; return nums[0]; &#125; return findMin(nums, 0, nums.length - 1);&#125;public static int findMin(int[] nums, int left, int right)&#123; if (nums[left] &lt; nums[right])&#123; return nums[left]; &#125; if (left == right)&#123; return nums[left]; &#125; if (left + 1 == right)&#123; return Math.min(nums[left], nums[right]); &#125; int mid = (left + right) / 2; //solution1和solution2任选一个 //solution1 if (nums[mid] &gt; nums[left])&#123; return findMin(nums, mid+1, right); &#125;else&#123; return findMin(nums, left, mid); &#125; //solution2 //return Math.min(findMin(nums, left, mid), findMin(nums, mid+1, right));&#125; 二分解法思路： 和递归的解法相同，同样也需要注意边界的处理。 1234567891011121314151617181920public static int findMin(int[] nums)&#123; if (nums == null || nums.length == 0)&#123; return 0; &#125; int l = 0, r = nums.length - 1; while (l &lt;= r)&#123; if (nums[l] &lt;= nums[r])&#123; return nums[l]; &#125; int m = (i + j) / 2; if (nums[m] &gt;= nums[i])&#123; l = m + 1; &#125;else&#123; r = m; &#125; &#125; return nums[l];&#125;]]></content>
      <categories>
        <category>练一练？</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>算法题</tag>
        <tag>分治</tag>
        <tag>二分</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[README]]></title>
    <url>%2F2019%2F06%2F11%2F%E6%BA%90%E7%A0%81%E4%B9%8B%E6%97%85%2FREADME%2F</url>
    <content type="text"><![CDATA[第一次有意识地阅读源码，平时只是看看文档，并未对源码深究。本篇仅作记录源码学习的历程，希望能看到自己的成长。]]></content>
      <categories>
        <category>源码之旅</category>
        <category>jdk9</category>
      </categories>
      <tags>
        <tag>源码之旅</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Median of Two Sorted Arrays]]></title>
    <url>%2F2019%2F06%2F10%2F%E7%BB%83%E4%B8%80%E7%BB%83%EF%BC%9F%2FMedian-of-Two-Sorted-Arrays%2F</url>
    <content type="text"><![CDATA[题目要求：在两个排好序的数组中找出中位数（从小到大排序） 官方题解 思路： 将题目转换为找第k大的数。假设数组A长度为m，数组B长度为n，就是找出第(m+n)/2大的数(奇数)，或者是第(m+n)/2大的数与第(m+n)/2+1大的数的和的平均数(偶数)。 因为要求的复杂度是log级别，且数组是有序的，很容易想到用二分法。指针i指向数组A，指针j指向数组B，然后更替两个指针的下标，这样很容易写成递归的形式。1234567891011//这个函数用来查找两个排好序的数组的中位数double findMedianSortedArrays(int[] nums1, int[] nums2);//这个函数用来找第k大的数/** * nums1的区间是[L1,R1) * nums2的区间是[L2,R2) * k是在这个区间nums1和nums2的区间内查找第k大的数 * 返回第k大的数*/int getKth(int[] nums1, int L1, int R1, int[] nums2, int L2, int R2, int k) 二分搜索的思路指针i和指针j将数组分成了两部分，并且满足 i + j == k 所以我们可以对数组A进行二分搜索，即i = (0 + m) / 2,而j的值也就确定了，即 j = k - i 如何更替指针i和j将数组A和数组B分成如下两部分（可以看成两个隔板在移动），第k大的数一定是A[i-1]或者B[j-1]中123 left part | right partA[0] A[1] ... A[i-1] | A[i] A[i+1] ... A[m-1]B[0] B[1] ... B[j-1] | B[j] B[j+1] ... B[n-1] 数组A的隔板可以有m+1种放置方式，而数组B的隔板随着A的变动而变动。 这时候考虑两种可能： A[i-1] &lt;= B[j]，那么第k大的数一定落在数组A的[i,m-1]区间和数组B的[0,j-1]区间内。此时A的隔板需要向右移动 A[i-1] &gt; B[j]，那么第k大的数一定落在数组A的[0,i-1]区间和数组B的[j,n-1]区间内，此时A的隔板需要向左移动 那么更新的步骤也很容易写，进行递归就行了。 细节和边界处理这题细节太多了(太菜了也是一方面)，来捋一捋细节部分。 递归的停止条件1int getKth(int[] nums1, int L1, int R1, int[] nums2, int L2, int R2, int k) L1 &gt;= R1 这就说明数组A的[L1,R1-1]部分全部划到了left part，那么 k = 0 第k大的数已经在left part中了，但是要小心j可能为0的情况 k != 0 那么第k大的数在B中，在B中数出k-i个数就行 L2 &gt;= R2 与L1&gt;=R1同理 k = 0 找出已知的左半部分的最大值就行。但是注意i为0，j为0的边界情况 i和j的更替 上面说到对指针i进行二分搜索，可能会出现指针不移动的情况，所以用Math.ceil()来保证指针的移动(至少移动一个位置)，为了方便，再令A数组的长度m始终小于等于B数组的长度n 因为区间的划分是左闭右开，一般情况下更替后进行判断的值是A[i-1]和B[j-1]。但是需要注意j可能出现不更新的情况（简单的例子：k=1，i向右走了一步，此时j不需要移动，所以判断的值就变成了A[i-1]和B[j]） 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class TwoNine&#123; public static double findMedianSortedArrays(int[] nums1, int[] nums2)&#123; int m = nums1.length, n = nums2.length; if (m &gt; n)&#123; int[] temp = nums1; nums1 = nums2; nums2 = temp; &#125; if ((m+n)%2==0)&#123; return (getKth(nums1, 0, nums1.length, nums2, 0, nums2.length, (m+n)/2+1) + getKth(nums1, 0, nums1.length, nums2, 0, nums2.length, (m+n)/2)) / 2.0; &#125;else&#123; return getKth(nums1, 0, nums1.length, nums2, 0, nums2.length, (m+n+1)/2); &#125; &#125; //num1区间[L1, R1), nums2区间[L2, R2) public static int getKth(int[] nums1, int L1, int R1, int[] nums2, int L2, int R2, int k)&#123; if (L1 &gt;= R1)&#123; return k == 0 ? nums1[L1-1] : nums2[L2 + k - 1]; &#125; if (L2 &gt;= R2)&#123; return k == 0 ? nums2[L2-1] : nums1[L1 + k - 1]; &#125; if (k == 0)&#123; //说明第k个数不会落在[L1, R1)和[L2,R2)上 if (L1 == 0)&#123; return nums2[L2-1]; &#125;else if (L2 == 0)&#123; return nums1[L1-1]; &#125;else&#123; return Math.max(nums1[L1-1], nums2[L2-1]); &#125; &#125; /** * i表示将nums1划分为两个区间:[L1, i),[i, R1) * j同理 * 所以[L1, i-1]和[L2, j-1]属于左半部分 */ int stepi = (int)Math.ceil((R1-L1)/2.0); //加上Math.ceil是为了避免走不动,例如R1=3,L1=2,这样i就不会变化了 int stepj = k - (int)Math.ceil((R1-L1)/2.0); //stepj可能为0 int i = L1 + stepi; int j = L2 + stepj; //这里注意j有可能为0,m=n时j可能为0 if (stepj != 0)&#123; if (nums1[i-1] &lt;= nums2[j-1])&#123; //必须有等号 return getKth(nums1, i, R1, nums2, L2, R2, k - stepi); &#125;else&#123; return getKth(nums1, L1, i, nums2, j, R2, k - stepj); &#125; &#125;else&#123; if (nums1[i-1] &lt;= nums2[j])&#123; //必须有等号 return getKth(nums1, i, R1, nums2, L2, R2, k - stepi); &#125;else&#123; return getKth(nums1, L1, i, nums2, j+1, R2, k-1); &#125; &#125; &#125;&#125; 其它的指针移动方式复杂度要求是log并不代表必须用二分的方式移动指针，还可以用其它方式来移动这两个指针。]]></content>
      <categories>
        <category>练一练？</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工厂(Factory)模式]]></title>
    <url>%2F2019%2F06%2F07%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂模式概述简单工厂模式的改进 工厂模式 定义一个用于创建对象的接口，但是让子类决定将哪个类实例化，工厂方法模式让一个类的实例化延迟到其子类。 与简单工厂模式的区别（以自己博客的代码为例）： 在简单工厂模式中，假设这次需要生产一辆拖拉机，那么就需要增加一个拖拉机类，同时修改工厂类，决定按什么方式生产这辆拖拉机。 而在工厂模式中，还是需要生产一辆拖拉机，对原先的代码不需要改动，同样是增加一个拖拉机类，然后增加一个专门生产拖拉机的工厂。 这样就解决了简单工厂模式的不符合开闭原则的问题。 组成 抽象工厂(Factory)，工厂模式的核心，所有的工厂类都要继承该接口。 抽象产品(Product)，产品的接口。 具体工厂(ConcreteFactory)，调用其方法可以获得一个具体产品类的实例。 具体产品(ConcreteProduct)。 例子抽象工厂 123456public interface Factory &#123; public Product createProduct();&#125;public interface Product &#123; public void use();&#125; 抽象产品123public abstract class Product&#123; public abstract void use();&#125; 具体工厂12345678910111213public class BikeFactory implements Factory&#123; @Override public Product createProduct() &#123; return new Bike(); &#125;&#125;public class CarFactory implements Factory&#123; @Override public Product createProduct() &#123; return new Car(); &#125;&#125; 具体产品123456789101112public class Bike implements Product&#123; @Override public void use() &#123; System.out.println(&quot;Bike......tututu&quot;); &#125;&#125;public class Car implements Product&#123; @Override public void use() &#123; System.out.println(&quot;Car......tututu&quot;); &#125;&#125; 使用123456789101112public class User&#123; public static void main(String[] args) &#123; Factory bikeFactory = new BikeFactory(); Product bike = bikeFactory.createProduct(); bike.use(); Factory carFactory = new CarFactory(); Product car = carFactory.createProduct(); car.use(); &#125;&#125; 再画一下类图： 工厂模式的优点 用户只需要关心产品对应的工厂，而不需要关心创建产品的细节，甚至也不需要知道自己使用的产品。（例如对工厂类进一步封装，提供了一个方法，该方法包括创建产品和提供产品服务，这样用户只需要调用该方法，连产品的名称也不必知道） 加入新产品时无需修改客户端，也无需修改其他的具体工厂和具体产品，只要增加一个具体工厂和具体产品即可。使得系统具有良好的扩展性，符合开闭原则。 工厂模式的缺点每次增加一个产品都需要添加一个工厂类和产品类，使得系统中类的数量成对增加，增加了系统复杂度。 使用场景 客户端不知道它所需要的对象的类。 例如对于数据库访问，不需要关心采用哪种数据库，只关心能够提供的服务。 日志记录器。用户可能将日志记录到本地硬盘、远程服务器等。 抽象工厂类通过其子类来指定创建哪个对象。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模版(Template)模式]]></title>
    <url>%2F2019%2F06%2F07%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E6%A8%A1%E7%89%88%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[模版模式：父类(abstract class)定义处理的流程，子类实现具体内容的处理。核心就是子类继承父类。打个比方就是你老爹有一笔钱要留给你，规定了这笔钱的用法（比如不能搞黄赌毒），你必须满足要求才有使用权。 还是写个例子吧12345678910abstract class Shape&#123; abstract void draw();&#125;class Circle extends Shape&#123; @Override void draw()&#123; draw_a_circle(); &#125;&#125; UML类图太简单就不画了 什么情况下使用呢？ 有时候一些类可能需要的操作是一样的，可以把这些类的共同点抽象出来，变成一个模版，后面的类只要继承这个模版就行了（类似于地基）。 优点： 公共代码，易于维护 封装不变部分，扩展可变部分 缺点： 如果每一个新功能的实现都需要一个子类完成，那么子类的数量会很多，变得难以维护。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[适配器(Adapter)模式]]></title>
    <url>%2F2019%2F06%2F07%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[适配器模式是什么？类似于转接口、读卡器一类的东西：例如USB接口不能直接读取SD卡的内容，但是将SD卡放入读卡器，在将读卡器插入USB接口就可以读取SD卡的内容。适配器就是能让某个设备在两台互不兼容的机器上实现转换的设备。 实现适配器的方式 类适配器模式（使用继承） 对象适配器模式（使用委托） 类适配器模式（使用继承）123456789101112131415161718192021222324252627282930313233343536//现在有一张SD卡class SDCard&#123; String readData()&#123; //读取SD卡数据的方法 &#125; void writeData(String data)&#123; //写入SD卡数据的方法 &#125;&#125;//这是要求的USB接口interface USB&#123; void usbWrite(String data); String usbRead();&#125;//这是适配器class Adapter extends SDCard implements USB&#123; @Override void usbWrite(String data)&#123; writeData(data); &#125; @Override String usbRead()&#123; return readData(); &#125;&#125;class User&#123; void use()&#123; //有了适配器之后，就可以连接USB读取SD卡的内容 USB usb = new Adapter(); adapter.usbWrite(); adapter.useRead(); &#125;&#125; 常规的模式如下 对象适配器模式（使用委托）委托就是自己不干活，交给另一个人做。A需要做一件事，然后将这件事委托给B完成。 12345678910111213141516171819202122232425262728293031323334353637//现在有一张SD卡class SDCard&#123; String readData()&#123; //读取SD卡数据的方法 &#125; void writeData(String data)&#123; //写入SD卡数据的方法 &#125;&#125;//这是要求的USB接口abstract class USB&#123; abstract void usbWrite(String data); abstract String usbRead();&#125;//这是适配器class Adapter extends SDCard&#123; private SDCard sdCard; @Override void usbWrite(String data)&#123; sdCard.writeData(data); &#125; @Override String usbRead()&#123; return sdCard.readData(); &#125;&#125;class User&#123; void use()&#123; //有了适配器之后，就可以连接USB读取SD卡的内容 USB adpater = new Adapter(); adapter.usbWrite(); adapter.useRead(); &#125;&#125; 与类适配器模式差别就在于对目标接口（USB）的处理方式。类适配器使用实现接口，对象适配器使用继承（因为只能单继承，所以在适配器中需要包含SD类） 什么时候使用适配器模式？ 现有的类已经满足了我们的需求，我们希望将这些类作为组件重复利用。（没有必要重复造轮子） 版本升级与兼容，可以使用Adapter模式使新旧版本兼容。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对角线遍历]]></title>
    <url>%2F2019%2F06%2F06%2F%E7%BB%83%E4%B8%80%E7%BB%83%EF%BC%9F%2F%E5%AF%B9%E8%A7%92%E7%BA%BF%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[对角线遍历 给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。 示例： 输入: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] 输出: [1,2,4,7,5,3,6,8,9] 思路：分两种情况讨论，一种是向上走，一种是向下走。 如何区分当前属于向上或者向右呢？注意到斜着移动时不改变奇偶性（因为指向行和指向列的指针一加一减）。具体来说：就是两个下标相加为偶数时正在右上方移动，两个下标相加为奇数时正在往左下方移动。 向上走走到不能再走又分为两种情况，一种是可以向右走（例如M&gt;=N的矩形）；一种是向下走（M&lt;=N的矩形） 向下走与向上走同理，走到尽头也可以分为两种情况，一种是向下走（例如M&gt;=N的情况）；另一种是向右走（例如M&lt;=N的情况） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123; public int[] findDiagonalOrder(int[][] matrix) &#123; if(matrix == null || matrix.length == 0)&#123; return new int[0]; &#125; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); int row = matrix.length, col = matrix[0].length; int i = 0, j = 0; while (i &lt; row &amp;&amp; j &lt; col)&#123; list.add(matrix[i][j]); if ((i+j)%2==0)&#123; //向上走 if (i == 0)&#123; if (j == col -1)&#123; i += 1; &#125;else&#123; j += 1; &#125; &#125;else if (j == col - 1)&#123; i += 1; &#125;else&#123; i -= 1; j += 1; &#125; &#125;else&#123; //向下走 if (j == 0)&#123; if (i == row - 1)&#123; j += 1; &#125;else&#123; i += 1; &#125; &#125;else if (i == row - 1)&#123; j += 1; &#125;else&#123; i += 1; j -= 1; &#125; &#125; &#125; int[] res = new int[list.size()]; for (i = 0; i &lt; list.size(); i++)&#123; res[i] = list.get(i); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>练一练？</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Partition Labels]]></title>
    <url>%2F2019%2F06%2F02%2F%E7%BB%83%E4%B8%80%E7%BB%83%EF%BC%9F%2FPartition-Labels%2F</url>
    <content type="text"><![CDATA[题目 思路： 找出每个字符第一次出现和最后一次出现的位置，这样就可以看成是一个又一个的区间，抽象出来就是合并区间的操作。（题目也可以改成给定一些区间，将overlap的地方合并之后还有几个区间） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import java.util.ArrayList;import java.util.Arrays;import java.util.Scanner;public class OneTwo&#123; public static void main(String[] args) &#123; System.out.println(partitionLabels(&quot;helloworld&quot;)); System.out.println(partitionLabels(&quot;ababfeefhijkh&quot;)); &#125; public static int partitionLabels(String s)&#123; if (s == null || s.length() == 0)&#123; return 0; &#125; Interval[] intervals = new Interval[26]; for (int i = 0; i &lt; intervals.length; i++)&#123; intervals[i] = new Interval(); intervals[i].left = 0; intervals[i].right = 0; &#125; for (int i = 0; i &lt; s.length(); i++)&#123; char ch = s.charAt(i); intervals[ch-&apos;a&apos;].left = intervals[ch-&apos;a&apos;].left == 0 ? i+1 : Math.min(intervals[ch-&apos;a&apos;].left, i+1); intervals[ch-&apos;a&apos;].right = intervals[ch-&apos;a&apos;].right == 0 ? i+1 : Math.max(intervals[ch-&apos;a&apos;].right, i+1); &#125; Arrays.sort(intervals); int sum = 0; int left = 1; int right = 1; for (int i = 1; i &lt; intervals.length; i++)&#123; if (intervals[i].left &gt; right)&#123; sum++; left = intervals[i].left; right = intervals[i].right; &#125;else&#123; right = Math.max(right, intervals[i].right); &#125; if (i == intervals.length - 1)&#123; sum++; &#125; &#125; return sum; &#125;&#125;class Interval implements Comparable&lt;Interval&gt;&#123; int left = 0; int right = 0; Interval()&#123;&#125; @Override public int compareTo(Interval to)&#123; if (left != to.left)&#123; return left - to.left; &#125;else&#123; return right - to.right; &#125; &#125;&#125;]]></content>
      <categories>
        <category>练一练？</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《巨人的陨落》随笔？]]></title>
    <url>%2F2019%2F06%2F02%2F%E5%B7%A8%E4%BA%BA%E7%9A%84%E9%99%A8%E8%90%BD%2F</url>
    <content type="text"><![CDATA[README感谢学校图书馆和QQ的合作，为我们提供了免费的正版电子书（希望在关闭前能把扫到的几本书看完…更正，毕业前） 。这篇文章既不是读后感也不是赏析，只是个人的肤浅见解和茶余饭后的瞎BB。 2019-06-02书刚看过半，终于明白了：这是一部以历史为原型的小说。以一战前后为背景，讲述了渺小的个人在战争中的故事，从这几个人的身上可以窥见社会的缩影。贵族也好，工人也罢，所有人的命运都因为战争而改变。作者为我们开启了上帝视角，带我(们，需要加们吗)走进一个波澜壮阔的时代，也带我(们)了解了一个从未感受过的一战，那就是在历史书上最容易被忽视的——生命，和我们一样有情感、有思想、有梦想的生命，正是这些与我们并无差异的生命共同构成了这段历史。 Three years I’ve though of nothing except Titanic. But I never got it. I never let it in.——Titanic 作者采用分镜头的写法，主要介绍了五个国家的几个家庭（不容易计算就没数了），这几个家庭的命运看似独立，实则相互联系，纵横交织。作者以宏大的历史为背景，为我们讲述了一个精彩的故事，在这里，巨人陨落，英雄崛起。 2019-06-03 - 2019-06-04吃饱了再写一点 五个国家的大致概况。 英国 罢工频繁，社会主义思想盛行； 爱尔兰争取独立（？不太记得）； 自由党和保守党之争，首相软弱无力，面对战争摇摆不定，最终将英国推向一战； 议会分为上议院和下议院，上议院由贵族组成，下议院由人民选举； 应该处于慢慢没落的时期（从菲茨认为英国应该领导世界的想法看出来，不少国家已经开始挑战英国的霸主地位）； 普法做得很到位，或者说民主精神深入人心（但是上议院的席位由出身决定，看起来也不民主）。比利小学没念完就成了矿工，这应该是工人阶级的普遍情况，但是英国人知道通过立法、通过投票的手段争取和维护自己的权益。 俄国 腐败至极：德国的百姓可以低价买到俄国生产的鞋子，俄国士兵却要赤脚作战；牧师猥亵儿童；内部的政府官员自愿出卖国家；俄国警察可以随便殴打，逮捕群众；特权阶级可以随意处死百姓。 沙皇的权威在一二十年内不断下降。格雷戈里小时候被父母带着在路边跪拜沙皇（沙皇是爸爸）—&gt; 母亲带着格雷戈里两兄弟跪下求见沙皇（沙皇出于某些理由让百姓受苦）—&gt; 格雷戈里兵变（去你妈的沙皇）。愚蠢的皇室广播仇恨的种子，亲手培养自己的掘墓人。 德国 欧洲崛起的强国。普鲁士崛起，文治武功，在普法战争中打败法国，逼迫法国割让阿尔萨斯和洛林，最终统一了整个德意志，成为欧洲的强国。 谋求新的殖民地，以及有扩张的野心（从与墨西哥的py交易可以看出，与墨西哥做军火生意，同时希望与英国战争时墨西哥可以对英国实行石油禁运，这笔生意实际上同时惹到英国和美国） 皇帝和大臣过于傲慢，自认为什么都懂，低估了美国的力量。 奥地利 着墨较少，在谈到沃尔特的表弟时提及。萨拉热窝事件，斐迪南作为奥地利的继承人被塞尔维亚人强杀，至于是由塞尔维亚政府组织还是自发的，已经无所谓了。奥地利强迫塞尔维亚政府接受条约，大战一触即发。然而我搞不懂为什么沃尔特的表弟一再强调：奥地利必须进攻。因为尊严受到践踏？还是国家利益受到损害？还是奥地利发生了国内危机需要一场战争？ 美国 崛起的强国，并且国力持续强盛，工人的生活条件也最好。和其他国家一样，美国也有罢工，也有工会，美国梦并不像欧洲人宣传的那么好，不过是刚脱虎口，又入狼窝。 一战最大的赢家，大发战争财，出售军火和物资，同时贷款给协约国支持作战。然而威尔逊总统却又希望和平，建立国际秩序，真是讽刺（总统不过是资本选举出来的代言人）。 一战后期向德国宣战，这是显然的。威尔逊口口声声希望和平，却拉偏架：协约国和同盟国作战，美国为协约国提供物资和军火，同盟国对来往货轮进行无差别攻击我认为没什么不对的，这些货轮事实上也参与了战争，严格来说，是美国人把自己推向了战争，他们从一开始就参与了战争。 法国 革命不断，当然也不断地把国王推上断头台？在一战中依靠英国补给和俄国人在德国另一侧的牵制得以苟延残喘。看起来弱爆了？一战被吊打，二战直接亡国？实际上是对德作战主力军？ 2019-06-05写一写各个家庭的情况 英国比利家 比利 真·汉子。 出生在英国的矿工家庭，父亲是工会的重要人物，虽然只念了小学，但从小接受父亲的熏陶，拥有演讲才能以及分辨政府消息真伪的能力。 善良：相信有上帝的存在，在矿井中被恶意捉弄时凭借对上帝的信仰挺过了没有光线的时间，从此人称“耶稣比利”（原来叫比利乘二）。 勇敢：发生矿难时挺身而出，救出了XXX(忘记名字了╮(￣▽￣)╭)，然而他已经被烧死了，所以冒死拖出来的是一具尸体；顶撞父亲(为姐姐辩护）；身先士卒，带领阿伯罗温的小队成功拿下敌人一个火力点；爱上了有两个孩子的单身母亲米尔德里德(强调单身母亲的原因是因为世俗对单身母亲带有敌意，过去如此，现在大概也是这样，然而单身母亲作为弱势群体不是应该受到更多的关怀吗)。 聪明：得益于其父亲，能够看穿政府的谎言和伎俩，以及可以从不同的角度看待事物；在战场上总能想到好办法度过难关，带领战友在战场上一同生存。 口无遮拦：想说的东西必须一吐为快，在作战中慢慢看清战争的真相，因此多次顶撞上级，引发上级不满。 艾瑟尔 比利的姐姐，善良聪明，曾经在伯爵的家中打工，爱上伯爵，后因怀孕而遭到驱逐，成为普通的女工。和比利一样受到父亲的很多影响。 之前对上层社会是抱有幻想的，我想可能是在伯爵的别墅待得太久了，又爱上了菲茨的缘故。在发生矿难时提出希望国王慰问的意见，提出发放食物给因发生矿难而罢工的矿工的孩子，提出这些建议的理由是她希望人和人可以互相理解，让上层阶级可以多关心下层人民。被赶出别墅之后，受到了许多不公正的对待(一是因为女性的身份，二是因为单身母亲)成为女权主义者，为女性权益奔走发声，在这一过程中，也慢慢地看清资本家的面目(从对菲茨的态度可以看出，爱情让人盲目，喜欢他的时候浑身发光，不喜欢的时候马上发现其冷酷、自私的本性╮(￣▽￣)╭)。 比利的父亲 工会的重要代表，冷静，用特有的方式关爱家人，对子女可能过于严厉。一直把比利当孩子看待，比利为其姐姐与父亲大吵一架之后父子之间几乎没有像样的交流了，直到比利参军时，才将他当成大人对待(父母的通病吗╮(￣▽￣)╭)。因艾维尔怀孕一度与她决裂。 比利的母亲 比利的外公 着墨不多，就和正常人的母亲和正常人的外公一样。母亲总能看穿比利的心思。 伯尼 艾薇尔的丈夫，工会成员，十分聪明，能够条理清晰地解释一件事。艾薇尔喜欢菲茨，最终发现伯尼才是自己的精神伴侣，遂接受伯尼的追求。 菲茨家 碧公主 俄国公主，对百姓没有同情心（怪不得你们家会被推翻），远嫁英国，但从未把英国当成家，小时候就跟着哥哥处死三个农民，因为它们的牛在自家土地上吃草。冷酷自私，追求享受，喜欢炫耀，虽然长得很漂亮，但是与性格形成了反差，让人觉得恶心。 菲茨 世袭伯爵，英国最富有的人之一。不过在我看来就是蠢猪一只，书中最讨厌的角色，没有之一。虚伪；冷酷；虚荣傲慢；不负责任；满脑子想着玩女人；虽然接受过贵族教育，但是其智力表现还不如只读完小学的工人阶级；完美地诠释什么叫“肉食者鄙”。如果非要说点好话，他的优点就是长得帅和有钱。 还是多写几句话骂他吧。 虚伪 为罢工工人的孩子提供食物 这是艾瑟尔出的主意，看起来菲茨似乎做了件好事。但实际上，菲茨是煤矿的真正主人（从法律上来说，当然马克思会反对的）。菲茨不直接经营煤矿，但是会按时收取租金和一定比例的利润，工人罢工是因为煤矿公司赶走了遇到矿难的矿工的妻子，菲茨拿着剥削矿工的钱招待矿工的孩子，还想博得慈善的称号。 资助或开办医院、收容所（？）等地方 这些实际上是茉黛在操作，只不过花的是伯爵的钱。他自己甚至不知道有这些事情，只是茉黛出于伯爵名声的考虑为菲茨操劳。 拄着拐杖，戴着眼罩参加追悼会 一场作秀而已，表明自己负伤也为国家作出了共享。然而并非如此。 首先，菲茨是支持这场战争的，没有战争就不会有牺牲。 其次，菲茨作为战斗的指挥官，这些士兵的牺牲与他的无能和不作为密切相关。 最后，尽管造成了这么多的牺牲，这么多的家破人亡，菲茨依旧呼吁继续战争。 菲茨不切腹谢罪也应感到惭愧和自责，但是却腆着B脸参加追悼会？毫无战绩，还在前线玩女人的军官也有资格和牺牲者相提并论？ 没有责任感 对于国家：支持英国参战；不懂指挥却越级上报 对于家庭：从书上来看，那个年代的英国应该是一夫一妻制，菲茨的枪却频频走火，这里放一枪，那里开一炮。在家里搞女管家，肚子弄大了之后希望用一年25镑打发走她；到法国巴黎作战，和酒吧女孩睡到一块（碧还在怀孕）；到俄国参加反布尔什维克战斗，和俄国女孩睡到一块。然后做完了之后感觉有轻微的愧疚感。 智力 这个没啥好说，精虫上脑的家伙能有什么智力。 茉黛 女权主义者，在前半本书误会了她，因为我认为参加上流社会的聚餐和宴会不能叫女权主义者，一战开始之后，茉黛参加集会，办报刊，为妇女权益和反战发声。 勇敢追求幸福，在战争前夕嫁给了敌国的沃尔特。这对恋人在四年的战争中只相处过两个夜晚，凭借着忠贞不渝和主角光环，最后也是个happy ending。 理想主义者，认为自己是天生的领袖，以及有些激进。仅因意见不和就与共事了一两年的艾瑟尔分道扬镳。 德国沃尔特家 沃尔特 头脑清醒，渴望和平的年轻人，但被迫卷入战争。是外交官，也是间谍，或者说情报人员。 奥托 沃尔特的父亲，骄傲自大，渴望战争，能够清楚地看清当前的政治形势，但是低谷了美国佬的力量。 俄国格雷戈里家 格雷戈里 好大哥，真汉子。亲眼目睹父母的死亡，不得不担负起照顾小列夫的重任，将列夫拉扯大。责任感极强，富有同情心，敢想敢做。 对沙皇的仇恨：年幼时目睹父亲被俄国的王子和碧公主吊死，只因为父亲在王子的无人耕作的田地上放牧。年长些被母亲带着求见沙皇，跪地时被下令朝百姓开枪的士兵打死，抱着浑身是血的母亲回到家，此后开始与列夫相依为命的日子，也在心中埋下了仇恨的种子。最后参与兵变逼走沙皇，见证废除帝制的时刻。 家庭的担当：从小与列夫相依为命，虽不说对列夫教育得多好，但是言传身教是肯定有的。后来列夫犯事逃跑，留下了怀孕的卡婕琳娜，格雷戈里也尽心尽力地照顾她，临别参军时也抵制了卡婕琳娜的诱惑。 列夫 人渣。明明有个好大哥，却不知道列夫为什么会是人渣。没有责任和担当，下了个蛋就跑。不懂感恩，冷血自私，包养情妇，打死岳父，最后还图谋妻子的财产。 美国格斯家 格斯的母亲 只记得她瞧不上穷人。 格斯 才华横溢的年轻人，因一篇论文而得到威尔逊的赏识，直接进入白宫成为总统的助手。感情之路不是很顺利，几段感情都没有结果，甚至订婚时被列夫戴了绿帽，然而后面运气挺好，与聪明又富有魅力的独眼的女记者相爱。 一点牢骚2019-07-01 一战是由资本家发起的战争，是为了少数人的利益而引起的战争，但是上战场吃枪子的却不是有权是否发动战争的人。 战争带来的只有破坏(当然，对美国佬来说就不一定了)，几百万人不事生产，扛枪上战场，除了破坏还能干吗？战争进入对峙状态，两边的士官藏在阴冷的战壕里，时刻警惕着子弹和敌人的偷袭，嚼着难以下咽的食物，能想到的可能只有当初坚定地认为需要一场战争的想法，但是为什么发动战争呢？理由早已忘却。 生命是可以用金钱衡量的。各国的首脑都看出了短期是不可能结束战争的，而且双方早已厌烦了战争，但是英法却否决了和平的提案，因为打仗向美国借了一大笔钱，所以他们希望能够打赢这场战争，把这笔钱转嫁到战败国的人民身上。 书中描绘了战败后的德国：殖民地被洗劫一空，面临天价的战争赔款，物价飞涨，货币贬值，物资匮乏，就算是出身贵族的茉黛也得去酒吧打工，忍受客人的猥亵。显然这是来自协约国的疯狂报复（凉透的沙皇就不算在内了），所以书中第三部分取名为’世界重生’感觉不太准确。1920年一战正式结束，1939年二战开始。如此的疯狂报复使得和平持续了不到20年的时间。 战后和平指南(来自书中人物观点)：建立国际秩序；帮助德国恢复经济；不过过分剥削德国。 舆论是可以引导的，真相是可以粉饰的。 丘吉尔指责俄国的新闻法令，禁止报纸反对政府，但是没有说英国的上议会席位是由出身决定的。 英国的愚民政策，对舆论的把控比控制报纸更为肮脏。 乔治·巴罗显然从未见过任何地图，却觉得自己高于笛卡尔、伦勃朗和贝多芬。他有这种想法并不奇怪。多年的教育一直告诉他们英国打赢了哪些战争，却从来没提过败仗。他们了解伦敦的民主，却对开罗的暴政一无所知。当他们了解英国的正义时，并不提及澳大利亚的鞭刑、爱尔兰的饥饿或印度的大屠杀。当他们知晓天主教徒在火刑柱上烧死新教徒，但如果他们发现新教徒得到机会也会对天主教徒做同样的事时，就会大为震惊，他们的父亲很少会像比利的爸爸那样，告诉他们，教科书里描绘的世界是一个幻想。 紧接上一条，政治是肮脏的，世界很残酷 窃钩者诛窃国者侯 你没钱的时候银行一分钱也不会借你，当你不缺钱的时候，银行拼命地想把钱借给你 如果欠银行一百万没有还，你是孙子，银行会将你告上法庭，变卖你的资产抵债；如果欠银行一百个亿没有还，银行是孙子，还得小心地伺候你这个大爷。 没有永远的朋友，也没有永远的敌人，只有永远的利益。]]></content>
      <categories>
        <category>码畜的自我修养</category>
      </categories>
      <tags>
        <tag>瞎BB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java泛型(1)]]></title>
    <url>%2F2019%2F06%2F01%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%B3%9B%E5%9E%8B-1%2F</url>
    <content type="text"><![CDATA[泛型是什么泛型是程序设计语言的特性，类似于C++的模版类 为什么需要泛型因为懒 泛型的简单使用用菱形运算符括起来，放在正确的位置就行了。 泛型类12345678910111213141516171819202122232425262728public class GenericClassTest&#123; public static void main(String[] args)&#123; Pair&lt;Integer, String&gt; pair = new Pair&lt;&gt;(10, &quot;hello&quot;); System.out.println(pair.getKey()); System.out.println(pair.getValue()); &#125;&#125;//泛型类写法class Pair&lt;K, V&gt;&#123; K key; V value; public Pair(K key, V value)&#123; this.key = key; this.value = value; &#125; public Pair()&#123; &#125; public K getKey()&#123; return key; &#125; public V getValue()&#123; return value; &#125;&#125; 泛型方法12345678910111213141516171819202122232425262728293031323334353637383940public class GenericFunTest&#123; public static void main(String[] args)&#123; System.out.println(getString(&quot;hello&quot;)); System.out.println(getString(&quot;world&quot;, &quot;nothing&quot;)); System.out.println(getString(new String[]&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;)); String[] a = new String[]&#123;&quot;d&quot;, &quot;e&quot;, &quot;f&quot;&#125;; System.out.println(getString(a)); &#125; //泛型写在返回值之前 public static&lt;T&gt; String getString(T input)&#123; System.out.println(&quot;public static&lt;T&gt; String getString(T)&quot;); return input.toString(); &#125; public static&lt;T, V&gt; String getString(T input, V nouse)&#123; System.out.println(&quot;public static&lt;T,V&gt; String getString(T, V)&quot;); return input.toString(); &#125; //也可以传入多个泛型 public static&lt;T&gt; String getString(T...a)&#123; System.out.println(&quot;public static&lt;T&gt; String getString(T...a)&quot;); StringBuffer sb = new StringBuffer(); for (T temp:a)&#123; sb.append(temp.toString()); &#125; return sb.toString(); &#125; //这种方法和上面的定义等价 //写一个就好 public static&lt;T&gt; String getString(T[] a)&#123; System.out.println(&quot;public static&lt;T&gt; String getString(T[]a)&quot;); StringBuffer sb = new StringBuffer(); for (int i = 0; i &lt; a.length; i++)&#123; sb.append(a[i].toString()); &#125; return sb.toString(); &#125;&#125; 泛型的复杂使用以在集合中找到最小数为例，逐渐改进泛型的写法 类型限界（type bound）假如我们希望找出一个数组中的最小值，但又不愿为每个类型的数组都写基本相同的代码，这时候可以使用泛型。但不是所有的元素都是可以比较的，因此需要限定传入的数组参数，具体来说就是传入实现了Comparable接口的元素。 1234567891011121314151617181920212223242526272829303132333435public static&lt;T extends Comparable&gt; T min(T[] array)&#123; System.out.println(&quot;public static&lt;T extends Comparable&gt; T min(T[] array)&quot;); if (array == null || array.length == 0)&#123; return null; &#125; T res = array[0]; for (int i = 1; i &lt; array.length; i++)&#123; if (res.compareTo(array[i]) &gt; 0)&#123; res = array[i]; &#125; &#125; return res;&#125; //如果希望有多个限定呢？可以写成这样//这两个函数实际上重复了，下面这个包含了上面那个，写一个就好 public static&lt;T extends Comparable &amp; Serializable&gt; T min(T[] array)&#123; System.out.println(&quot;public static&lt;T extends Comparable &amp; Serializable&gt; T min(T[] array)&quot;); if (array == null || array.length == 0)&#123; return null; &#125; T res = array[0]; for (int i = 1; i &lt; array.length; i++)&#123; if (res.compareTo(array[i]) &gt; 0)&#123; res = array[i]; &#125; &#125; return res; &#125;public static void main(String[] args) &#123; Integer[] test = new Integer[]&#123;1,2,3,4,5&#125;; Integer res = min(test); System.out.println(res);&#125; 第一次修改以上代码有缺陷，在if条件内，编译之后有这样的提示：对作为原始类型Comparable的成员的compareTo(T)的调用未经过检查 Comparable本身就是泛型接口，所以进行第一次修改，改成这样：1public static&lt;T extends Comparable&lt;T&gt;&gt; min(T[] array) 改成这样好在哪里？编译时不会提示使用了未检查或不安全的操作。 不安全的操作是什么？我们只希望T和T进行比较，所以在Comparable后面又加上了限定类型T。 例如这样子（想了好久的例子，不知道恰不恰当） 123456789101112131415161718192021222324252627282930313233343536373839404142class A implements Comparable&lt;A&gt;&#123; int value; A(int value)&#123; this.value = value; &#125; A()&#123;&#125; @Override public int compareTo(A a)&#123; if (value &gt; a.value)&#123; return 1; &#125;else if (value &lt; a.value)&#123; return -1; &#125; return 0; &#125;&#125;class B implements Comparable&lt;B&gt;&#123; int value; B()&#123;&#125; B(int value)&#123; this.value = value; &#125; @Override public int compareTo(B b)&#123; if (value &gt; b.value)&#123; return 1; &#125;else if (value &lt; b.value)&#123; return -1; &#125; return 0; &#125;&#125;public static&lt;T extends Comparable&gt; int min(T a, T b)&#123; return a.compareTo(b);&#125;public static void main(String[] args) &#123; A a = new A(10); B b = new B(5); System.out.println(min(a, b));&#125; 上面这段代码可以通过编译，但是运行时出错： Exception in thread “main” java.lang.ClassCastException:B cannot be cast to A 但是利用第一次修改，在传参时就可以检查出错误了 协变 还不够完美，还可以再复杂一点。在这之前先介绍个名词，covariant（协变） 百度百科的解释： 协变是在计算机科学中，描述具有父/子型别关系的多个型别通过型别构造器、构造出的多个复杂型别之间是否有父/子型别关系的用语。 那么问题来了，什么是型别？ 停，这样下去是没有止境的，让这些定义吃屎去吧，写出来的词语连汉语词典都查不到。 直接看代码：有一个抽象父类Shape，两个子类Circle和Oval各自继承Shape 1234567891011121314151617181920212223abstract class Shape&#123; public abstract String getShape();&#125;class Circle extends Shape&#123; public String getShape()&#123; return &quot;circle&quot;; &#125;&#125;class Oval extends Shape&#123; public String getShape()&#123; return &quot;oval&quot;; &#125;&#125;public static void main(String[] args) &#123; Shape[] shapes = new Circle[3]; shapes[0] = new Oval(); //编译可以通过，但是运行时报错，会抛出ArrayStoreException //shapes数组实际上存的是Circle的引用，但是Oval不是Circle所以报错 //System.out.println(shapes[0].getShape()); //Shape[]可以放Circle也可以放Oval，这就是协变&#125; 可以看到数组是协变的，but集合不是协变的，也就是123//数组是协变的，但集合不是协变的，例如以下代码无法运行 List&lt;Circle&gt; list = new ArrayList&lt;Circle&gt;(); list.add(new Circle()); 不是协变的也就缺少了灵活性（也就是需要多写代码），所以这会限制集合的使用（因为不想多写代码），为了弥补这个不足，就有了通配符 最后一次修改1public static&lt;T extends Comparable&lt;? super T&gt;&gt; T min(T[] array) 为什么写成这样？因为假如有个类A实现了Comparable&lt;A&gt;的接口，类B继承了A，A is-a Comparable&lt;A&gt;，这个是显然的，而B is-a Comparable&lt;A&gt;，但是B is-not-a Comparable&lt;B&gt;。所以min()方法中不能传入数组B。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class A implements Comparable&lt;A&gt;&#123; int value; A()&#123;&#125; A(int value)&#123; this.value = value; &#125; @Override public int compareTo(A a)&#123; if (value &lt; a.value)&#123; return -1; &#125;else if (value &gt; a.value)&#123; return 1; &#125;else&#123; return 0; &#125; &#125;&#125;class B extends A&#123; int value; B()&#123;&#125; B(int value)&#123; this.value = value; &#125; @Override public int compareTo(B b)&#123; if (value &gt; b.value)&#123; return 1; &#125;else if (value &lt; b.value)&#123; return -1; &#125; return 0; &#125;&#125;public static&lt;T extends Comparable&lt;? super T&gt;&gt; T min(T[] array)&#123; System.out.println(&quot;public static&lt;T extends Comparable&gt; T min(T[] array)&quot;); if (array == null || array.length == 0)&#123; return null; &#125; T res = array[0]; for (int i = 1; i &lt; array.length; i++)&#123; if (res.compareTo(array[i]) &gt; 0)&#123; res = array[i]; &#125; &#125; return res;&#125;public static void main(String[] args) &#123; B[] bs = new B[2]; bs[0] = new B(1); bs[1] = new B(2); B res = min(bs); System.out.println(res.value);&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Minimum Size Subarray Sum]]></title>
    <url>%2F2019%2F05%2F30%2F%E7%BB%83%E4%B8%80%E7%BB%83%EF%BC%9F%2FMinimum-Size-Subarray-Sum%2F</url>
    <content type="text"><![CDATA[题目 思路：利用左右两个指针，分别指向Subarray的左边和右边。 如果Subarray的和大于s，更新最小的长度，减去左边的指针对应的值，将左边的指针向右移动； 如果Subarray的和小于s，将右边的指针向右移动，同时更新和 1234567891011121314151617181920212223242526272829303132public class Eight&#123; public static void main(String[] args)&#123; System.out.println(minSubArrayLen(7, new int[]&#123;2,3,1,2,4,3&#125;)); &#125; //s &gt; 0, and any element in nums are bigger than zero public static int minSubArrayLen(int s, int[] nums)&#123; if (nums == null || nums.length == 0)&#123; return 0; &#125; int length = 0; int sum = 0; int leftPos = 0; int rightPos = 0; while (rightPos &lt;= nums.length)&#123; if (sum &gt;= s)&#123; length = length == 0 ? rightPos - leftPos : Math.min(length, rightPos - leftPos); sum -= nums[leftPos++]; &#125;else&#123; if (rightPos == nums.length)&#123; break; &#125; sum += nums[rightPos++]; &#125; &#125; return length; &#125;&#125;]]></content>
      <categories>
        <category>练一练？</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Trapping Rain Water]]></title>
    <url>%2F2019%2F05%2F30%2F%E7%BB%83%E4%B8%80%E7%BB%83%EF%BC%9F%2FTrapping-Rain-Water%2F</url>
    <content type="text"><![CDATA[题目 思路： 拆开来看，判断每个位置还能装多少水，这样每个位置能装的水取决于该位置左右两边的最大值 从左到右扫一遍，得到数组在该位置的左边的最大值（包括这个数） 从右到左扫一遍，得到数组在该位置的右边的最大值（包括这个数） 重新扫一遍数组，判断这个数是否比左边的最大值和右边的最大值小(可以和第二步一起做，减少一次遍历的时间） 12345678910111213141516171819202122232425public static int trap(int[] height)&#123; if (height == null || height.length &lt;= 2)&#123; return 0; &#125; int[] head = new int[height.length]; int[] tail = new int[height.length]; head[0] = height[0]; for (int i = 1; i &lt; height.length; i++)&#123; head[i] = Math.max(head[i-1], height[i]); &#125; tail[height.length - 1] = height[height.length - 1]; for (int i = height.length - 2; i &gt;= 0; i--)&#123; tail[i] = Math.max(tail[i+1], height[i]); &#125; int sum = 0; for (int i = 1; i &lt; height.length - 1; i++)&#123; if (height[i] &lt; head[i] &amp;&amp; height[i] &lt; tail[i])&#123; sum += Math.min(head[i], tail[i]) - height[i]; &#125; &#125; return sum; &#125;]]></content>
      <categories>
        <category>练一练？</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UML类图]]></title>
    <url>%2F2019%2F05%2F27%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FUML%E7%B1%BB%E5%9B%BE%2FUML%E7%B1%BB%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[UML：Unified Modeling Language，统一建模语言。是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。 为了更好地读懂和理解设计模式需要学习UML（通过图形分析各个类之间的关系比通过代码更加直观易懂），既然学了UML类图，所以再顺便学了一下如何使用StarUML绘制来绘制UML类图。 绘图工具：开源的StarUML 参考资料：StarUML使用教程 类图主要包括这几个部分：类（Class）、接口（Interface）、双向关联（Association）、单向关联（DirectedAssociation）、聚合关系（Aggregation）、组合关系（Composition）、依赖关系（Dependency）、泛化关系（Generalization）、实现（Realization） StarUML中的类视图选项。先学上面列举的，暂时够用就行。 ## 用了IDEA之后，来更正了，不用学StarUML也是OK的，能看懂就行了，IDEA自带生成类图工具… 类视图类视图的表示方法 12345678910public class Person&#123; private int age; public String name; protected String race; public Person()&#123;&#125; public Person(int age, String name, String race)&#123;&#125; public int getAge()&#123; return age; &#125;&#125; 用UML类图表示的Person如下 上面是Attribute，也就是字段（属性），同一行分别表示：访问权限（可见性） 字段名 类型 “-“:private “+”:public “#”:protected “~”:package（默认访问权限） 下方是Operation（应该也可以叫Method），也就是方法。对应的是 访问权限 方法名 返回类型 接口123public interface IShape&#123; double getArea();&#125; 跟类的UML表示方法基本一样，只是上方多了&lt;&lt;&gt;&gt; 类与类的关系双向关联（Association）用不带箭头的实线表示。 老师给多个同学上课，同学有多个老师。 单向关联（DirectedAssociation）用带箭头的实现表示。 顾客的信息包括产品信息，产品信息不包括顾客 聚合关系（Aggregation）常见表示方法：一端带箭头，一端带空心菱形的实线 HAS-A。整体与部分的关系。一个对象作为另一个对象的成员存在，或者说一个对象是另一个对象的一部分。成员是整体对象的一部分，但是成员对象也可以脱离整体对象存在。 引擎是汽车的一部分，所以汽车和引擎是聚合关系。 表示方法似乎有两种，一种带箭头，一种不带箭头 带箭头的用得似乎更多一些？ 组合关系（Composition）常见表示方法：一端带箭头，一端带实心菱形的实线。 整体与部分的关系。但是整体对象可以控制成员对象的生命周期，成员对象与整体是同生共死的关系。 还是用汽车和引擎的例子。 同样是带箭头和不带箭头的画法。 泛化关系（Generalization）用一端带空心三角形的实线表示。 IS-A。直接理解为继承就行 依赖关系（Dependency）用带箭头的虚线表示。 USE-A的关系。一个对象需要使用另一个对象 #类与接口的关系 实现关系（Realization）用一端带空心三角形的虚线表示 实现接口。 扩展各种关系的强弱顺序 泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖 关系的强弱指什么？ 类与类之间的耦合度。可以理解为其中一个类发生变化时对另外一个类的影响程度。 为什么是上面那个顺序？ 这个问题慢慢想。 通过类图寻找关键的类 实体类：实体类对应系统需求中的每个实体，它们通常需要保存在永久存储体中，一般使用数据库表或文件来记录，实体类既包括存储和传递数据的类，还包括操作数据的类。实体类来源于需求说明中的名词，如学生、商品等。 控制类：控制类用于体现应用程序的执行逻辑，提供相应的业务操作，将控制类抽象出来可以降低界面和数据库之间的耦合度。控制类一般是由动宾结构的短语（动词+名词）转化来的名词，如增加商品对应有一个商品增加类，注册对应有一个用户注册类等 边界类：边界类用于对外部用户与系统之间的交互对象进行抽象，主要包括界面类，如对话框、窗口、菜单等。 这个在学习过程中慢慢体会。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式README]]></title>
    <url>%2F2019%2F05%2F26%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FREADME%2F</url>
    <content type="text"><![CDATA[说明用于学习设计模式 前置知识 UML类图 设计模式 Iterator(迭代器)模式 Adapter(适配器)模式 Template Method(模版)模式 Factory Method(工厂)模式 Singleton(单例)模式 Prototype(原型)模式 Builder(建造者)模式 Abstract Factory(抽象工厂)模式 Bridge(桥)模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迭代器(Iterator)模式]]></title>
    <url>%2F2019%2F05%2F25%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[迭代器是什么？可以理解为指向某个元素的指针。（对Java中Iterator的更好理解是指向刚刚越过的那个元素，即该Iterator指向两个元素中间） 迭代器模式是什么？简单地理解就是按下面这种方式对容器进行遍历的方式。 123while (it.hasNext())&#123; it.next();&#125; 例子。 Aggregate接口。可以理解为容器，123public interface Aggregate&#123; public abstract Iterator iterator();&#125; Iterator接口。迭代器。1234public interface Iterator&#123; public abstract boolean hasNext(); public abstract Object next();&#125; Book对象。123456789public class Book&#123; private String name; public Book(String name)&#123; this.name = name; &#125; public String getName()&#123; return name; &#125;&#125; BookShelf对象。（放很多Book的容器）123456789101112131415161718192021public class BookShelf implements Aggregate&#123; private Book[] books; private int last = 0; public BookShelf(int maxsize)&#123; this.books = new Book[maxsize]; &#125; public Book getBookAt(int index)&#123; return books[index]; &#125; public void appendBook(Book book)&#123; this.books[last++] = book; &#125; public int getLength()&#123; return last; &#125; @Override public Iterator iterator()&#123; return new BookShelfIterator(this); &#125;&#125; BookShelfIterator迭代器。按某种方式查看书架上所有书的迭代器。12345678910111213141516171819202122public class BookShelfIterator implements Iterator&#123; private BookShelf bookShelf; private int index; public BookShelfIterator(BookShelf bookShelf)&#123; this.bookShelf = bookShelf; this.index = 0; &#125; @Override public boolean hasNext()&#123; if (index &lt; bookShelf.getLength())&#123; return true; &#125;else&#123; return false; &#125; &#125; @Override public Object next()&#123; Book book = bookShelf.getBookAt(index); index++; return book; &#125;&#125; 按之前学过的UML类图，把这几个类的关系画出来。 迭代器模式的元素： 抽象集合（Aggregate） 抽象迭代器（Iterator） 具体集合（BookShelf） 具体迭代器（BookShelfIterator） 直接遍历容器不就行了，为什么需要迭代器模式？ 使用迭代器可以将遍历与实现分离。使用迭代器之后，只要依旧实现Aggregate接口的iterator()方法，仍然可以用Iterator的接口的hasNext()和next()方法进行遍历，而不用考虑容器的实现方式，即使是数组换成了Vector，或是换成ArrayList等容器，遍历的方式都不需要改变。 提供了一种方法顺序访问聚合对象中的各个元素，而又不暴露该对象的内部表示。不需要关心该集合是什么，也就是提供了更好的封装性。 可以通过迭代器自定义需要的遍历方式，例如对于数组可以是前向遍历，后向遍历，跳跃几个数据遍历；对于二叉树可以是前序，中序，后序遍历。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo自动生成的文章]]></title>
    <url>%2F2019%2F05%2F16%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. try this Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
